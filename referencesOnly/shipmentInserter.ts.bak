// Backup:
import { db } from '@/lib/database/drizzle';
import type { PgTransaction } from 'drizzle-orm/pg-core';
// Corrected import for Neon HTTP transaction result type
import type { NeonHttpQueryResultHKT } from 'drizzle-orm/neon-http'; 
import type { ExtractTablesWithRelations } from 'drizzle-orm';
import * as schema from '@/lib/database/schema';
import { type ParsedShipmentBundle } from '@/types/parser.types';
import { eq, and, SQL } from 'drizzle-orm';
import type { NeonHttpTransaction } from '@/types/database.types'; 
import { logger } from '@/utils/logger';
// ***** ADDED IMPORT for mock address resolver *****
import { findOrCreateMockAddress } from '@/services/geolocation/mockAddressResolver'; 

interface InsertionResult {
  success: boolean;
  shipmentId?: string; // Return the new shipment ID on success
  error?: string;
}

// Helper to safely convert string/number to decimal string format for DB
// Drizzle expects strings for decimal types
function toDbDecimal(value: string | number | null | undefined): string | null {
    if (value === null || value === undefined) return null;
    const num = Number(value);
    if (isNaN(num)) return null;
    // Basic formatting, might need adjustment based on DB precision needs
    return num.toFixed(2); // Example: 2 decimal places
}

/**
 * Inserts a complete ParsedShipmentBundle into the database within a single transaction.
 * Handles finding/creating related entities like addresses, trucks, drivers.
 *
 * @param bundle The parsed shipment data bundle.
 * @returns InsertionResult indicating success or failure.
 */
export async function insertShipmentBundle(
  bundle: ParsedShipmentBundle
): Promise<InsertionResult> {
  logger.debug(
    `[insertShipmentBundle] Received bundle for Row ${bundle.metadata?.originalRowIndex} with pickupAddressRaw: '${bundle.metadata?.rawOriginInput}', destinationAddressRaw: '${bundle.metadata?.rawDestinationInput}'`
  );

  const sourceDocId = bundle.metadata?.sourceDocumentId ?? '[Unknown Document]';
  const identifier = `Row ${bundle.metadata?.originalRowIndex ?? '?'}`;

  // Input Validation (Neurotic Check)
  if (!bundle || !bundle.shipmentBaseData || !bundle.metadata) { // Check core parts
    console.error('Invalid ParsedShipmentBundle received (missing core data): ', bundle);
    return { success: false, error: 'Invalid bundle data provided.' };
  }

  try {
    const result = await db.transaction(async (tx: any): Promise<InsertionResult> => { // TODO: Fix NeonHttpTransaction type mismatch
      console.log(`Starting transaction for ${identifier} from doc ${sourceDocId}`);
      logger.debug(`[TX ${identifier}] START`);

      // Declare IDs higher up in scope
      let originDbId: string | null = null;
      let destinationDbId: string | null = null;
      let truckId: string | null = null;
      let driverId: string | null = null;
      let tripId: string;
      let shipmentId: string;
      let pickupId: string | null = null;
      let dropoffId: string | null = null;

      // --- 1. Insert/Find Addresses (using bundle data) ---
      // ***** MODIFIED ORIGIN ADDRESS LOGIC *****
      const rawOriginInput = bundle.metadata?.rawOriginInput;
      logger.debug(`[TX ${identifier}] Processing Origin Address. Raw Input: '${rawOriginInput}'`);

      if (rawOriginInput) { // Priority 1: Use raw input for mock resolution
        try {
          originDbId = await findOrCreateMockAddress(tx, rawOriginInput);
          if (originDbId) {
            logger.info(`[TX ${identifier}] Resolved origin via mock lookup. Address ID: ${originDbId}`);
          } else {
            logger.warn(`[TX ${identifier}] Mock address resolution failed or returned null for raw input: '${rawOriginInput}'. Will check bundle.originAddressData.`);
          }
        } catch (mockError: any) {
           logger.error(`[TX ${identifier}] Error during findOrCreateMockAddress call: ${mockError.message}. Proceeding without mock resolution.`, mockError);
           originDbId = null; // Ensure null if mock call throws error
        }
      }

      // Priority 2: If mock resolution failed OR no raw input, use bundle.originAddressData (if valid)
      if (!originDbId && bundle.originAddressData && bundle.originAddressData.resolutionMethod !== 'none') { 
        logger.debug(`[TX ${identifier}] Attempting fallback using bundle.originAddressData.`);
        try {
          // Build conditions array, filtering out undefineds
          const originConditions: (SQL<unknown> | undefined)[] = [
            bundle.originAddressData.street1 ? eq(schema.addresses.street1, bundle.originAddressData.street1) : undefined,
            bundle.originAddressData.city ? eq(schema.addresses.city, bundle.originAddressData.city) : undefined,
            bundle.originAddressData.postalCode ? eq(schema.addresses.postalCode, bundle.originAddressData.postalCode) : undefined,
            bundle.originAddressData.country ? eq(schema.addresses.country, bundle.originAddressData.country) : undefined
          ];
          const validOriginConditions = originConditions.filter((c): c is SQL<unknown> => c !== undefined);

          let existingOrigin: { id: string } | undefined = undefined;
          if (validOriginConditions.length > 0) { // Only query if there are conditions
            existingOrigin = await tx.query.addresses.findFirst({
              where: and(...validOriginConditions), // Spread the valid conditions
              columns: { id: true }
            });
          }

          if (existingOrigin) {
            originDbId = existingOrigin.id;
            logger.debug(`[TX ${identifier}] Found existing origin address ID via fallback data: ${originDbId}`);
          } else {
            logger.debug(`[TX ${identifier}] Attempting to insert origin address using fallback data: ${JSON.stringify(bundle.originAddressData)}`);
            const insertedOrigin = await tx.insert(schema.addresses)
              .values(bundle.originAddressData)
              .returning({ id: schema.addresses.id });
            if (!insertedOrigin || insertedOrigin.length === 0 || !insertedOrigin[0]?.id) {
              throw new Error('Failed to insert fallback origin address or retrieve ID.');
            }
            originDbId = insertedOrigin[0].id;
            logger.debug(`[TX ${identifier}] Inserted new origin address ID via fallback data: ${originDbId}`);
          }
        } catch (fallbackError: any) {
          logger.error(`[TX ${identifier}] CATCH during Fallback Origin Address processing: ${fallbackError.message}`, fallbackError);
          originDbId = null; // Ensure null if fallback fails
        }
      }

      // Handle case where neither mock lookup nor fallback data yielded an ID
      if (!originDbId) {
         logger.warn(`[TX ${identifier}] Could not determine a valid Origin Address ID from mock lookup or bundle data. Origin address will be null for associated pickup.`);
         // originDbId remains null
      }

      // ***** END MODIFIED ORIGIN LOGIC *****

      // --- Destination Address (Keep existing logic, seems okay for now) --- 
      logger.debug(`[TX ${identifier}] Processing Destination Address. Data provided: ${!!bundle.destinationAddressData}`);
      if (bundle.destinationAddressData) { // Check if address data exists first
           try {
                // Build conditions array, filtering out undefineds
                const destConditions: (SQL<unknown> | undefined)[] = [
                    bundle.destinationAddressData.street1 ? eq(schema.addresses.street1, bundle.destinationAddressData.street1) : undefined,
                    bundle.destinationAddressData.city ? eq(schema.addresses.city, bundle.destinationAddressData.city) : undefined,
                    bundle.destinationAddressData.postalCode ? eq(schema.addresses.postalCode, bundle.destinationAddressData.postalCode) : undefined,
                    bundle.destinationAddressData.country ? eq(schema.addresses.country, bundle.destinationAddressData.country) : undefined
                ];
                const validDestConditions = destConditions.filter((c): c is SQL<unknown> => c !== undefined);

                let existingDest: { id: string } | undefined = undefined;
                 if (validDestConditions.length > 0) { // Only query if there are conditions
                     existingDest = await tx.query.addresses.findFirst({
                         where: and(...validDestConditions), // Spread the valid conditions
                         columns: { id: true }
                     });
                }

                if (existingDest) {
                    destinationDbId = existingDest.id;
                    logger.debug(`[TX ${identifier}] Found existing destination address ID: ${destinationDbId}`);
                } else {
                   logger.debug(`[TX ${identifier}] Attempting to insert destination address: ${JSON.stringify(bundle.destinationAddressData)}`);
                   const insertedDest = await tx.insert(schema.addresses)
                        .values(bundle.destinationAddressData)
                        .returning({ id: schema.addresses.id });
                   if (!insertedDest || insertedDest.length === 0 || !insertedDest[0]?.id) {
                        throw new Error('Failed to insert destination address or retrieve ID.');
                   }
                   destinationDbId = insertedDest[0].id;
                   logger.debug(`[TX ${identifier}] Inserted new destination address ID: ${destinationDbId}`);
                }
            } catch (addrError: any) {
                logger.error(`[TX ${identifier}] CATCH during Destination Address processing: ${addrError.message}`, addrError);
                throw new Error(`Database error processing destination address: ${addrError.message}`);
            }
      } else {
          logger.warn(`[insertShipmentBundle] No destination address data provided in bundle for ${identifier}. Destination Address ID will be null.`);
          destinationDbId = null;
      }
      
      // --- 2. Find Truck (Insert deferred) --- 
      logger.debug(`[TX ${identifier}] Finding Truck. Identifier: ${bundle.parsedTruckIdentifier}`);
      if (bundle.parsedTruckIdentifier) {
        try {
          const existingVehicle = await tx.query.vehicles.findFirst({
            where: eq(schema.vehicles.plateNumber, bundle.parsedTruckIdentifier),
            columns: { id: true } // Only fetch the ID
          });
          if (existingVehicle) {
            truckId = existingVehicle.id;
            console.log(`Found existing vehicle with plate ${bundle.parsedTruckIdentifier}, ID: ${truckId}`);
          } else {
            console.log(`Vehicle with plate ${bundle.parsedTruckIdentifier} not found in DB. Proceeding without linking truck.`);
            // TODO: Optionally log this or handle differently (e.g., create with defaults if schema allows)
          }
        } catch (error) {
            console.error(`Error querying vehicles for plate ${bundle.parsedTruckIdentifier}:`, error);
            // Potentially throw to rollback, or just proceed with truckId = null?
            // For now, proceed with null to allow insertion to continue.
            // throw new Error('Database error during vehicle lookup.'); 
        }
      } else {
        console.log('No truck identifier provided in the bundle.');
      }
      logger.debug(`[TX ${identifier}] Found Truck ID: ${truckId}`);

      // --- 3. Find Driver (Insert deferred) --- 
      let foundDriver = null;

      logger.debug(`[TX ${identifier}] Finding Driver. Phone: ${bundle.parsedDriverPhone}, Name: ${bundle.parsedDriverName}`);
      try {
        // Prioritize lookup by phone if available
        if (bundle.parsedDriverPhone) {
          const driversByPhone = await tx.query.drivers.findMany({ // Use findMany in case phone isn't unique
            where: eq(schema.drivers.phone, bundle.parsedDriverPhone),
            columns: { id: true }
          });
          if (driversByPhone.length === 1) {
            foundDriver = driversByPhone[0];
            console.log(`Found unique driver by phone ${bundle.parsedDriverPhone}, ID: ${foundDriver.id}`);
          } else if (driversByPhone.length > 1) {
            console.warn(`Multiple drivers found with phone ${bundle.parsedDriverPhone}. Cannot reliably link driver.`);
          }
        }

        // If not found by phone, try by name (less reliable)
        if (!foundDriver && bundle.parsedDriverName) {
           const driversByName = await tx.query.drivers.findMany({ // Use findMany in case name isn't unique
            where: eq(schema.drivers.name, bundle.parsedDriverName),
            columns: { id: true }
          });
           if (driversByName.length === 1) {
            foundDriver = driversByName[0];
            console.log(`Found unique driver by name "${bundle.parsedDriverName}", ID: ${foundDriver.id}`);
          } else if (driversByName.length > 1) {
            console.warn(`Multiple drivers found with name "${bundle.parsedDriverName}". Cannot reliably link driver.`);
          }
        }

        // Assign ID if a unique driver was found
        if (foundDriver) {
          driverId = foundDriver.id;
        } else {
          console.log(`Driver not found or not uniquely identified by phone ('${bundle.parsedDriverPhone || 'N/A'}') or name ('${bundle.parsedDriverName || 'N/A'}'). Proceeding without linking driver.`);
          // TODO: Optionally log this or handle differently
        }

      } catch (error) {
        console.error(`Error querying drivers for phone ${bundle.parsedDriverPhone} or name ${bundle.parsedDriverName}:`, error);
        // Proceeding with driverId = null
      }
      logger.debug(`[TX ${identifier}] Found Driver ID: ${driverId}`);

      // --- 4. Create Trip --- 
      try {
        // Prepare data for trip insertion
        // Most fields are nullable or have defaults, include the ones we have
        const tripInsertData = {
          truckId: truckId, // Can be null
          driverId: driverId, // Can be null
          driverName: bundle.parsedDriverName, // Potentially null
          remarks: bundle.customDetailsData?.remarks, // Potentially null
          // tripConfigId and materialTransporter are omitted, allowing DB default or null
          // TODO: Populate other fields like material, materialType, status etc. if available/needed
          tripStatus: 'PENDING', // Example default status
        };

        logger.debug(`[TX ${identifier}] Attempting to insert Trip: ${JSON.stringify(tripInsertData)}`);
        const insertedTrips = await tx.insert(schema.trips)
          .values(tripInsertData)
          .returning({ id: schema.trips.id });

        if (!insertedTrips || insertedTrips.length === 0 || !insertedTrips[0].id) {
          throw new Error('Failed to insert trip or retrieve its ID.');
        }
        tripId = insertedTrips[0].id;
        logger.info(`[TX ${identifier}] Created Trip record with ID: ${tripId}`);

      } catch (error:any) {
        logger.error(`[TX ${identifier}] CATCH during Trip insertion: ${error.message}`, error);
        throw new Error(`Failed to create Trip record: ${error.message}`); 
      }

      // --- REORDERED: 5. Insert Shipment (Initial) --- 
      try {
        const initialShipmentInsertData = {
          ...bundle.shipmentBaseData,
          tripId: tripId,
          pickupId: null, // Set to null initially
          dropoffId: null, // Set to null initially
          sourceDocumentId: bundle.metadata.sourceDocumentId,
          status: 'PENDING', 
        };
        logger.debug(`[TX ${identifier}] Attempting initial Shipment insert: ${JSON.stringify(initialShipmentInsertData)}`);
        const insertedShipments = await tx.insert(schema.shipmentsErd)
          .values(initialShipmentInsertData)
          .returning({ id: schema.shipmentsErd.id });
        if (!insertedShipments || insertedShipments.length === 0 || !insertedShipments[0].id) {
          throw new Error('Failed to insert initial shipment or retrieve ID.');
        }
        shipmentId = insertedShipments[0].id;
        logger.info(`[TX ${identifier}] Inserted initial Shipment record with ID: ${shipmentId}`);

      } catch (error: any) {
        logger.error(`[TX ${identifier}] CATCH during initial Shipment insertion: ${error.message}`, error);
        throw new Error(`Failed to create initial Shipment record: ${error.message}`);
      }

      // --- REORDERED: 6. Insert Pickup --- 
      logger.debug(`[TX ${identifier}] Processing Pickup. Data provided: ${!!bundle.pickupData}`);
      if (bundle.pickupData) {
        try {
          // Now include shipmentId and the resolved originDbId
          const pickupInsertData = { 
            ...bundle.pickupData, 
            tripId: tripId, 
            addressId: originDbId, // Use the determined originDbId
            shipmentId: shipmentId // ADDED shipmentId
          }; 
          logger.debug(`[TX ${identifier}] Attempting to insert Pickup: ${JSON.stringify(pickupInsertData)}`);
          const insertedPickups = await tx.insert(schema.pickups)
            .values(pickupInsertData)
            .returning({ id: schema.pickups.id });
          if (!insertedPickups || insertedPickups.length === 0 || !insertedPickups[0].id) {
            throw new Error('Failed to insert pickup or retrieve ID.');
          }
          pickupId = insertedPickups[0].id;
          logger.info(`[TX ${identifier}] Inserted Pickup record with ID: ${pickupId}`);
        } catch (error: any) {
          logger.error(`[TX ${identifier}] CATCH during Pickup insertion: ${error.message}`, error);
          throw new Error(`Failed to create Pickup record: ${error.message}`);
        }
      } else {
        logger.warn(`[TX ${identifier}] No pickup data provided.`);
      }

      // --- REORDERED: 7. Insert Dropoff --- 
      logger.debug(`[TX ${identifier}] Processing Dropoff. Data provided: ${!!bundle.dropoffData}`);
      if (bundle.dropoffData) {
        try {
          // Now include shipmentId
          const dropoffInsertData = { 
            ...bundle.dropoffData, 
            tripId: tripId, 
            addressId: destinationDbId,
            shipmentId: shipmentId // ADDED shipmentId
           };
          logger.debug(`[TX ${identifier}] Attempting to insert Dropoff: ${JSON.stringify(dropoffInsertData)}`);
          const insertedDropoffs = await tx.insert(schema.dropoffs)
            .values(dropoffInsertData)
            .returning({ id: schema.dropoffs.id });
          if (!insertedDropoffs || insertedDropoffs.length === 0 || !insertedDropoffs[0].id) {
            throw new Error('Failed to insert dropoff or retrieve ID.');
          }
          dropoffId = insertedDropoffs[0].id;
          logger.info(`[TX ${identifier}] Inserted Dropoff record with ID: ${dropoffId}`);
        } catch (error: any) {
          logger.error(`[TX ${identifier}] CATCH during Dropoff insertion: ${error.message}`, error);
          throw new Error(`Failed to create Dropoff record: ${error.message}`);
        }
      } else {
         logger.warn(`[TX ${identifier}] No dropoff data provided.`);
      }

      // --- NEW STEP: 8. Update Shipment with Pickup/Dropoff IDs ---
      try {
          if (pickupId || dropoffId) { // Only update if there's something to link
              logger.debug(`[TX ${identifier}] Attempting to update Shipment ${shipmentId} with Pickup ID: ${pickupId}, Dropoff ID: ${dropoffId}`);
              await tx.update(schema.shipmentsErd)
                  .set({
                      pickupId: pickupId,
                      dropoffId: dropoffId,
                  })
                  .where(eq(schema.shipmentsErd.id, shipmentId));
              logger.info(`[TX ${identifier}] Updated Shipment ${shipmentId} with Pickup/Dropoff links.`);
          } else {
               logger.debug(`[TX ${identifier}] Skipping Shipment update as no Pickup/Dropoff IDs were generated.`);
          }
      } catch (error: any) {
          logger.error(`[TX ${identifier}] CATCH during Shipment update with Pickup/Dropoff IDs: ${error.message}`, error);
          throw new Error(`Failed to update Shipment ${shipmentId} with Pickup/Dropoff IDs: ${error.message}`);
      }

      // --- REORDERED: 9. Insert Custom Details --- 
      if (bundle.customDetailsData) {
        try {
          const customDetailInsertData = {
            ...bundle.customDetailsData,
            shipmentId: shipmentId, // Link to the created shipment
          };
          logger.debug(`[TX ${identifier}] Attempting to insert Custom Details: ${JSON.stringify(customDetailInsertData)}`);
          await tx.insert(schema.customShipmentDetails).values(customDetailInsertData);
          logger.info(`[TX ${identifier}] Inserted Custom Shipment Details for Shipment ID: ${shipmentId}`);
        } catch (error: any) {
          logger.error(`[TX ${identifier}] CATCH during Custom Details insertion: ${error.message}`, error);
          throw new Error(`Failed to create Custom Details record: ${error.message}`);
        }
      } else {
         logger.warn(`[TX ${identifier}] No custom details data provided.`);
      }

      // --- REORDERED: 10. Insert Items --- 
      logger.debug(`[TX ${identifier}] Processing ${bundle.itemsData?.length || 0} items.`);
      if (bundle.itemsData && bundle.itemsData.length > 0) {
        for (const item of bundle.itemsData) {
          try {
            const itemInsertData = { ...item, shipmentId: shipmentId };
            logger.debug(`[TX ${identifier}] Attempting to insert Item: ${JSON.stringify(itemInsertData)}`);
            await tx.insert(schema.items).values(itemInsertData);
            logger.debug(`[TX ${identifier}] Inserted Item: ${item.itemNumber || 'No item number'}`);
          } catch (error: any) {
            logger.error(`[TX ${identifier}] CATCH during Item insertion (Item: ${item.itemNumber}): ${error.message}`, error);
            throw new Error(`Failed to insert Item ${item.itemNumber}: ${error.message}`);
          }
        }
        logger.info(`[TX ${identifier}] Finished inserting ${bundle.itemsData.length} items for Shipment ID: ${shipmentId}`);
      } else {
        logger.warn(`[TX ${identifier}] No items provided in bundle.`);
      }

      // --- 11. Insert into document_shipment_map ---
      logger.debug(`[TX ${identifier}] Processing Document Map. Source Doc ID: ${sourceDocId}`);
      if (sourceDocId && sourceDocId !== '[Unknown Document]') {
        try { 
          const valuesToInsert = { documentId: sourceDocId, shipmentId: shipmentId };
          logger.debug(`[TX ${identifier}] Attempting to insert Document Map: ${JSON.stringify(valuesToInsert)}`); 
          await tx.insert(schema.documentShipmentMap).values(valuesToInsert); 
          logger.debug(`[TX ${identifier}] Created Document-Shipment map for Doc ${valuesToInsert.documentId} and Shipment ${valuesToInsert.shipmentId}`);
        } catch (mapError: any) { 
          logger.error(`[TX ${identifier}] CATCH during Document Map insertion: ${mapError.message}`, mapError);
          throw new Error(`Database error inserting document map: ${mapError.message}`); 
        }
      } else {
        logger.warn(`[TX ${identifier}] Skipping document map insertion due to missing source document ID.`);
      }

      // --- Transaction Success --- 
      logger.info(`[TX ${identifier}] COMMIT: Successfully completed transaction for ${identifier} (Shipment ID: ${shipmentId})`);
      return { success: true, shipmentId: shipmentId };

    }); // End of db.transaction callback
    return result; 

  } catch (error: any) {
    // Log the error that caused rollback from the outer catch
    logger.error(`[TX ${identifier}] ROLLBACK: Transaction failed for ${identifier} from doc ${sourceDocId}: ${error.message}`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
} // End of insertShipmentBundle function