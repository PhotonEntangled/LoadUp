# tactiq.io free youtube transcript
# Complete Backend Course | Build and Deploy Your First Production-Ready API
# https://www.youtube.com/watch/rOpEN1JDaD0

00:00:00.199 what if I told you that every time that
00:00:02.480 Netflix Spotify or Amazon go down it
00:00:05.560 costs them a million dollars every
00:00:08.360 minute but what's stopping that from
00:00:10.559 happening a quality backend while Sleek
00:00:13.559 front ends catch the eye it's the back
00:00:15.679 end that keeps everything running
00:00:17.400 smoothly handling data security and
00:00:20.359 performance behind the scenes and here's
00:00:22.640 the good news back in development isn't
00:00:25.240 as complicated as it sounds you don't
00:00:27.279 need to be a genius to get started so hi
00:00:30.240 there and welcome to my first ever
00:00:32.960 backend course where we're skipping the
00:00:35.040 basic CR tutorials and diving into the
00:00:37.520 real stuff building a production ready
00:00:40.039 subscription management system that
00:00:41.719 handles real users real money and the
00:00:44.520 real business logic this is the real
00:00:47.399 deal and today you'll learn all of it
00:00:50.360 from what backend development is and how
00:00:52.800 servers work under the hood to how you
00:00:55.120 can authenticate your users using jwt's
00:00:58.199 hook up a database create models and
00:01:00.359 schemas integrate with ORS and structure
00:01:03.600 the architecture of your API to make it
00:01:05.799 communicate with the front end then
00:01:07.680 we'll go Hands-On with the JavaScript
00:01:09.560 Mastery style and to build a secure
00:01:12.040 production grade subscription tracking
00:01:14.400 API with Advanced rate limiting and Bot
00:01:17.799 protection using arcjet that helps you
00:01:20.280 secure your whole app in just a few
00:01:22.240 lines of code database modeling and
00:01:24.439 relationships using mongodb and Mongoose
00:01:27.520 efficient user Crow operations and
00:01:29.600 subscrip description management Global
00:01:31.479 error handling input validation and
00:01:33.920 middleware integration implementing
00:01:36.000 logging mechanisms for better debugging
00:01:38.200 and monitoring and automating smart
00:01:40.560 email reminders with workflows using up
00:01:43.840 stash allowing you to schedule
00:01:45.399 notifications or any kind of business
00:01:47.520 logic you can think of and to top it all
00:01:49.640 off we'll take everything we built and
00:01:52.000 deploy it to your very own dedicated
00:01:55.000 scalable VPS server yep you heard that
00:01:58.079 right your own freaking server with full
00:02:01.039 rout access using hosting your VPS this
00:02:04.159 will give us full control to deploy your
00:02:06.079 API however you'd like how awesome is
00:02:08.679 that this video is your One-Stop shop
00:02:11.280 for becoming a real backend developer no
00:02:14.080 fluff no shortcuts just everything you
00:02:16.879 need all packed into one Epic video so
00:02:20.560 what are you waiting for let's break the
00:02:22.400 backend system that is hosting this
00:02:23.959 video by building this app together
00:02:34.560 have you ever wondered how the apps you
00:02:36.519 use every day actually work behind the
00:02:39.319 scenes from ordering food to sending
00:02:42.440 messages or streaming videos there's a
00:02:44.920 lot happening under the hood that most
00:02:46.920 people never see while the front end
00:02:48.879 looks sleek and interactive it's the
00:02:51.360 back end that keeps everything running
00:02:53.519 handling data security and performance
00:02:56.560 and if you thought about getting into
00:02:58.080 backend development you might feel like
00:03:00.319 it's too complex with servers databases
00:03:03.599 apis and authentication to figure out
00:03:06.159 but here's the thing it's not as
00:03:08.280 complicated as it seems and today you'll
00:03:11.120 learn it all so let's break it down the
00:03:13.680 web is split into two parts the front
00:03:16.280 end and the backend the front end is all
00:03:19.440 about user experience with three key
00:03:21.840 Parts the user which is you me or anyone
00:03:25.440 interacting with the app whether it's
00:03:27.280 scrolling through Instagram reading a
00:03:29.200 Blog or watching One YouTube video after
00:03:31.959 another the client which is a device or
00:03:34.680 an app like your browser that connects
00:03:37.080 us to the web and finally there's the
00:03:40.000 interface the layout and the design we
00:03:42.640 interact with built with nextjs react or
00:03:46.680 good old HTML CSS and JavaScript think
00:03:49.480 of the client your laptop phone or
00:03:52.200 tablet as a bridge connecting you to the
00:03:55.159 internet but where does that information
00:03:57.680 come from and how does it reach you
00:04:00.439 that's where servers come in a server is
00:04:02.959 just a powerful computer designed to
00:04:05.439 store process and send data it's a real
00:04:08.560 machine sitting in a data center
00:04:10.760 somewhere that you can own or rent
00:04:13.519 through services like AWS on the server
00:04:16.519 we store the backend code the logic that
00:04:19.279 handles everything from processing data
00:04:21.720 to managing users and interacting with
00:04:24.120 databases so how does your device the
00:04:27.120 client communicate with a random server
00:04:30.120 to get things done well here's how well
00:04:32.759 first you make a request when you visit
00:04:35.080 a website search for something or log
00:04:37.880 into an app your device sends a request
00:04:40.479 over the internet then that request
00:04:42.960 reaches a server which processes It This
00:04:45.440 Server could hold website data user
00:04:48.039 accounts or even real-time Nvidia stock
00:04:50.840 prices when deep seek got released and
00:04:53.400 finally the server response once it
00:04:56.120 processes your request it sends back the
00:04:58.360 data whether it's a web Page search
00:05:00.560 results or your messages so in the next
00:05:03.240 lesson let's dive deeper into how all of
00:05:06.000 this works under the
00:05:08.960 hood the entire handshake between the
00:05:11.919 client and the server happens in a Flash
00:05:15.199 faster than Thanos can snap his fingers
00:05:17.759 but for it to be that quick computers
00:05:20.280 need to speak the same language just
00:05:22.720 like we have different languages
00:05:24.600 computers follow rules of communication
00:05:27.199 called protocols and the most important
00:05:29.479 one
00:05:30.360 HTTP hypertext transfer protocol it's
00:05:34.400 the backbone of the internet when you
00:05:36.560 type google.com in your browser it uses
00:05:39.919 https the secure version to talk to
00:05:42.600 Google servers but before your device
00:05:45.520 can send that request it needs to find
00:05:48.319 the server and that's where DNS comes in
00:05:51.280 we use easy to remember names like
00:05:54.080 google.com but computers need IP
00:05:57.080 addresses like 1921
00:06:00.319 6811 to find each other and the domain
00:06:03.360 name system or a DNS is like the
00:06:06.000 internet's phone book it translates the
00:06:08.400 main names into IP
00:06:10.319 addresses here's how it works you type
00:06:12.880 in google.com the browser checks if it
00:06:15.400 already knows the IP and if not it asks
00:06:18.360 the DNS resolver the resolver searches
00:06:21.080 for the IP address and once found your
00:06:23.759 browser uses that IP to connect to
00:06:26.160 Google servers but what's an IP anyway
00:06:29.319 an IP address is a unique number that
00:06:32.639 identifies every device on the internet
00:06:35.400 think of it as your device's home
00:06:37.639 address there are two types ipv4 which
00:06:41.120 is a classic format but we're running
00:06:43.120 out of these and there's IPv6 which is a
00:06:46.240 newer format designed to support more
00:06:48.560 devices so now you know how your device
00:06:51.680 connects to a server but how does it
00:06:53.919 know what to ask for that's where apis
00:06:57.680 come in
00:07:00.120 we've talked about protocols the rules
00:07:02.720 for how clients and servers communicate
00:07:05.720 but how does your app actually talk to
00:07:08.199 the back end well that's where apis come
00:07:11.800 in an API which stands for application
00:07:15.319 programming interface is like a
00:07:17.520 restaurant waiter you the client are
00:07:20.919 hungry and you want to place an order
00:07:23.319 the waiter which is the API takes your
00:07:25.759 order to the kitchen and brings back
00:07:28.000 your food and and then the kitchen which
00:07:30.440 is the back end actually prepares your
00:07:32.639 meal but never interacts with you
00:07:34.520 directly and in Tech terms you would be
00:07:37.120 the client in this case the app or the
00:07:39.599 browser the waiter would be an API that
00:07:42.720 sends your request to the backend and
00:07:45.039 Returns the response and the kitchen
00:07:47.560 would be the actual backend that
00:07:49.720 processes the request and sends back the
00:07:51.879 data so for example when you scroll
00:07:54.000 through Instagram the apps API fetches
00:07:57.000 new posts from the back end and when you
00:07:59.120 check for the weather the API pulls the
00:08:01.560 data from a Weather Service without apis
00:08:05.240 your app and server wouldn't be able to
00:08:07.759 communicate they keep everything in sync
00:08:10.560 and apis follow a specific structure
00:08:13.360 that helps us manage and manipulate
00:08:15.479 resources be that data or objects that
00:08:18.520 can be created read updated or deleted
00:08:22.240 this is often referred to as crud so
00:08:25.440 let's break down the key components
00:08:27.520 first we have http methods or often
00:08:31.080 called verbs apis use HTTP methods to
00:08:35.200 Define what kind of action to take on a
00:08:37.599 specific resource let's go back to a
00:08:39.559 restaurant example a get request would
00:08:42.679 retrieve the data from the server like
00:08:45.000 looking at the menu or fetching the data
00:08:47.200 a post request would create a new
00:08:49.320 resource like placing an order or adding
00:08:52.120 new data a put or a patch call would
00:08:55.920 update an existing resource like
00:08:58.079 changing your order before it's made
00:09:00.320 which modifies the data and a delete
00:09:02.480 request would remove a resource like you
00:09:05.480 don't like your food and you cancel your
00:09:07.200 order which deletes the data alongside
00:09:09.920 these methods apis also have endpoints
00:09:14.000 an endpoint is a URL that represents a
00:09:16.880 specific resource or action in The
00:09:19.120 backend it's like telling the waiter
00:09:21.240 exactly what you want from the menu for
00:09:23.920 example get users would return a list of
00:09:26.959 users post users would create a new user
00:09:31.120 put users ID would update a specific
00:09:34.000 user and delete users ID would delete a
00:09:37.200 specific user later on we'll dive into
00:09:39.399 the best practices and naming
00:09:40.959 conventions behind API endpoints apis
00:09:44.560 also have headers and headers contain
00:09:47.760 extra information like metadata about
00:09:50.399 the request or a response like
00:09:52.959 authentication tokens content type or
00:09:55.959 caching instructions later on when we
00:09:58.279 developer great sub description tracking
00:10:00.320 API we'll use an authorization header
00:10:03.519 that will include your Bearer token that
00:10:05.680 verifies your identity now let's talk
00:10:07.959 about a request body when you use a post
00:10:11.040 or a put request to send the data to the
00:10:13.360 server the details go into the request
00:10:16.279 body usually in a Json format so when
00:10:20.000 you're creating a user you need to pass
00:10:22.240 the info from the front and form to the
00:10:24.640 backend API in form of adjacent like a
00:10:28.000 name and an email there's also a
00:10:30.600 response body which contains the data
00:10:33.120 the server sends back after processing
00:10:35.600 that request so for example if you're
00:10:37.680 trying to fetch all the users with the
00:10:39.800 get users call the server might return a
00:10:42.480 Json that would look something like this
00:10:45.000 all API calls also have something known
00:10:47.920 as status code to indicate what just
00:10:50.320 happened 200 means okay 2011 means that
00:10:54.279 you created something 400 means that
00:10:57.000 something went wrong and our wellknown
00:10:59.480 404 means that the resource doesn't
00:11:01.880 exist another common one is 500 which is
00:11:05.240 an internal server error saying that
00:11:07.800 something went wrong but we don't really
00:11:09.639 know what it is and if you want to know
00:11:11.720 more about status codes and all related
00:11:14.200 components of apis or best practices for
00:11:16.959 writing better apis you can check out
00:11:19.120 the complete backend sheet sheet I've
00:11:21.160 created for you it's completely free and
00:11:23.760 I'll link it down below this lesson but
00:11:26.120 with that in mind that's how apis work
00:11:28.800 behind the scenes but I know we've
00:11:30.920 covered a lot of stuff so let me recap
00:11:33.839 when you make an HTTP request here's
00:11:36.680 what happens first the client sends a
00:11:40.079 request to the server using the HTTP
00:11:43.399 protocol this request contains the HTTP
00:11:46.839 method like get or post the API endpoint
00:11:50.600 which is the F URL path you're calling
00:11:53.079 the headers which is the metadata like o
00:11:55.760 tokens or content types and finally the
00:11:58.600 body which which is the actual data
00:12:00.440 being sent for post input
00:12:03.200 requests after that the server then
00:12:05.959 processes the request and sends a
00:12:08.160 response that includes a status code
00:12:11.160 indicating success like 200 or an error
00:12:14.279 maybe a 404 as well as the body returned
00:12:17.720 by the server often in Json format
00:12:20.639 that's it that's all that apis are about
00:12:23.600 and what they're made
00:12:25.760 of now that you understand how apis work
00:12:29.440 let's explore the different types of
00:12:31.199 apis you'll
00:12:32.560 encounter first and most popular are
00:12:35.680 restful apis a rest or representational
00:12:39.440 state transfer API is the most common
00:12:42.399 thing you'll see it follows a structured
00:12:44.920 approach where clients interact with
00:12:47.440 resources using URLs and standard HTP
00:12:51.240 methods like get post put and delete
00:12:54.680 they're stateless which means that each
00:12:56.880 request is independent and doesn't rely
00:12:59.399 on previous ones and they typically use
00:13:02.000 Json making it super compatible across
00:13:04.920 all apps they're organized predictable
00:13:08.639 and easy to implement which is why
00:13:10.560 they're so widely used in web
00:13:12.040 development and the reason why you will
00:13:14.160 learn how to build one yourself today
00:13:16.600 there are also graphql apis developed by
00:13:19.519 Facebook which offer more flexibility
00:13:22.240 than Rest apis by letting clients
00:13:24.680 request exactly the data they need
00:13:27.279 instead of multiple endpoints for
00:13:28.839 different data graphql uses one/ graphql
00:13:33.399 endpoint and then clients can specify
00:13:36.320 the exact Fields they want without them
00:13:38.680 being previously defined in the code
00:13:40.880 which is super efficient for complex
00:13:42.880 applications with lots of interconnected
00:13:45.240 data so graphql really shines when
00:13:47.639 you're dealing with large data sets or
00:13:49.720 need to reduce over fetching or under
00:13:51.839 fetching data but to build any of these
00:13:54.480 apis you'll need a backend language so
00:13:58.360 let's explore our
00:14:00.480 C to build your apis you could use
00:14:03.839 languages like python Ruby Java or
00:14:07.320 JavaScript runtimes like node bun or
00:14:10.240 Dino and if I had to quickly show you
00:14:12.639 how to create a simple nodejs server it
00:14:15.320 would look something like this it's a
00:14:17.880 big mess writing all of this code from
00:14:20.199 scratch might feel a bit too much right
00:14:23.160 and that's where backend Frameworks come
00:14:25.199 in Frameworks provide a structured
00:14:27.759 foundation for building servers and they
00:14:30.440 handle repetitive tasks like routing
00:14:33.000 middleware and aor handling so you can
00:14:35.720 focus on your apps unique logic some of
00:14:38.759 the most popular backend Frameworks are
00:14:41.040 Express hono and nestjs for JavaScript
00:14:45.160 Jango for python Ruby on Rails for Ruby
00:14:49.079 and spring for Java in this course we'll
00:14:51.600 of course stick with the most popular
00:14:53.759 JavaScript framework which is of course
00:14:56.560 expressjs but if you'd like me to see
00:14:58.560 try home or Nest you can let me know
00:15:00.920 down in the comments but building a
00:15:03.000 backend isn't just about creating API
00:15:05.480 endpoints it's about managing data you
00:15:09.360 might think well why not just store the
00:15:12.120 data directly on the server well that's
00:15:15.199 inefficient and doesn't scale as your
00:15:17.560 app grows that's why every backend
00:15:20.800 relies on dedicated Storage Solutions
00:15:24.079 commonly known as
00:15:25.880 databases so in the next lesson we'll
00:15:28.639 dive into exactly how databases work the
00:15:31.839 different types you can use and how they
00:15:34.079 connect with your apis to manage data
00:15:36.639 efficiently let's keep
00:15:40.000 going now that you know how apis work
00:15:43.240 let's dive into one of the most critical
00:15:45.639 parts of backend development databases
00:15:48.120 at its core a database is just a system
00:15:51.199 that stores organizes and manages data
00:15:55.040 but let's break it down into simpler
00:15:56.920 terms think of a database as a
00:15:59.519 specialized software that lives on a
00:16:02.000 computer somewhere whether that's your
00:16:04.240 laptop a company server or a powerful
00:16:07.360 machine in a remote data center just
00:16:09.920 like your laptop stores files on a hard
00:16:12.319 drive or an SSD databases store data but
00:16:16.800 here's the difference databases are
00:16:19.160 optimized for Speed security and
00:16:22.160 scalability so whenever you log into
00:16:24.839 Instagram check out your bank account
00:16:27.000 balance or book a movie ticket a
00:16:29.880 database is working behind the scenes to
00:16:32.680 fetch update or store that information
00:16:35.839 and databases come in different flavors
00:16:38.360 but they're broadly classified into two
00:16:40.800 main types relational and non-relational
00:16:44.600 databases relational databases store
00:16:47.560 data in structured tables with rows and
00:16:50.959 columns much like a spreadsheet
00:16:53.160 relational databases use something known
00:16:55.680 as SQL a structured query language which
00:16:59.040 allows you to query and manipulate data
00:17:01.920 and most popular SQL databases are MySQL
00:17:05.319 or postgress you might want to use those
00:17:08.319 when your data is highly structured and
00:17:11.319 relationships between entities are
00:17:13.240 important think banking systems
00:17:15.799 e-commerce platforms or Inventory
00:17:18.160 management and if you're looking to
00:17:19.919 learn SQL with the latest orms like
00:17:22.599 Prisma check out my SQL databases course
00:17:25.359 on jm.pro I'll leave the link down below
00:17:28.960 but with that said let's explore non
00:17:31.640 relational databases also referred to as
00:17:34.480 nosql databases they offer more
00:17:37.960 flexibility and don't rely on a rigid
00:17:40.919 structure of tables they handled
00:17:43.679 unstructured or semi-structured data
00:17:46.200 making them perfect when data
00:17:47.880 relationships are less complex there are
00:17:50.960 also subtypes of nosql databases such as
00:17:54.440 document base like mongodb which stores
00:17:57.280 data in Json like Doc docents and
00:17:59.640 there's also some like reddis which
00:18:01.640 store data in simple key value pairs
00:18:04.360 nosql databases are great when handling
00:18:07.280 large volumes of data realtime analytics
00:18:10.200 or flexible data models think social
00:18:12.799 media apps iot devices or big data
00:18:16.000 analytics and like with the SQL course I
00:18:18.880 also have a short and sweet course on
00:18:20.960 mongodb with Mongoose that covers
00:18:23.799 everything from database Basics to
00:18:25.840 building a cool app so if you're into no
00:18:28.320 SQL databases check it out once again
00:18:31.120 the link is down below so let's be
00:18:33.280 honest which one is better well
00:18:36.000 unfortunately there's no one siiz fits
00:18:38.360 all here it depends on your business
00:18:40.080 needs but let me keep it simple if you
00:18:43.080 need structured data with clear
00:18:45.360 relationships go with relational or SQL
00:18:48.360 database and if you're handling massive
00:18:50.960 unstructured data or need flexibility go
00:18:53.720 for non-relational or non-sql
00:18:56.480 databases how would you actually make
00:18:58.440 your backend application interact with
00:19:01.520 that
00:19:02.320 database well the flow is the same for
00:19:05.039 both first the client or your device
00:19:08.360 sends a request to the backend for
00:19:10.960 example give me all my
00:19:13.400 subscriptions then the server processes
00:19:16.000 the request and determines what data is
00:19:18.720 needed then the backend sends a query to
00:19:21.760 the database to fetch update or delete
00:19:24.480 that data for example in SQL that might
00:19:27.840 look something like this this where you
00:19:29.440 select everything from subscriptions
00:19:31.600 where user ID is equal to something and
00:19:34.880 in no SQL like mongodb it'll look
00:19:37.280 something more similar to what you're
00:19:38.640 used to db. subscriptions. find and then
00:19:42.159 you pass in the user ID either way the
00:19:45.320 database will return the requested data
00:19:47.320 to the server and then the server
00:19:49.679 formats that data usually as Json and
00:19:53.200 sends it back to the client so that's it
00:19:56.159 you just learned how your server or your
00:19:58.320 app interacts with a database and that
00:20:01.159 is through queries we use queries to
00:20:04.600 store retrieve update or delete data in
00:20:08.200 databases you could use raw queries like
00:20:11.039 these ones here and writing those gives
00:20:13.159 you full control but also it can get a
00:20:15.559 bit tedious and error prone as your
00:20:18.080 project grows that's why many developers
00:20:20.960 decide to use orm object relational
00:20:24.520 mappers orms simplify database
00:20:27.440 interactions by letting you write
00:20:29.440 queries in a syntax of your programming
00:20:32.120 language of choice instead of writing
00:20:34.000 raw SQL for SQL databases popular orms
00:20:37.919 are Prisma and drizzle or even SQ eyes
00:20:41.760 and for nosql like mongodb there's
00:20:44.720 mongus here's how it would look like to
00:20:47.400 fetch a user using postr and here's how
00:20:50.280 it looks like to fetch it by using
00:20:53.240 Mongoose these ORS speed up the
00:20:55.919 development and help you prevent errors
00:20:58.320 ESP especially in larger projects and
00:21:00.480 remember those database courses that I
00:21:02.120 mentioned not that long ago well in
00:21:04.240 those I teach you how to use an orm no
00:21:07.000 matter which database you choose so if
00:21:09.240 you want to learn how to use an orm
00:21:11.279 definitely bookmark them and then
00:21:13.039 revisit them after watching this course
00:21:15.520 but with that in mind let's do a quick
00:21:17.960 databases
00:21:19.159 recap databases are specialized software
00:21:22.640 for storing organizing and managing data
00:21:26.600 they come in two main types relational
00:21:29.679 SQL and non-relational
00:21:32.799 nosql relational databases use
00:21:35.679 structured tables and SQL queries while
00:21:38.840 nosql offers flexibility with formats
00:21:42.120 like documents and key value Pairs and
00:21:44.880 you can interact with both databases
00:21:47.400 using either raw queries or simplify
00:21:50.559 things using orms that was a lot to
00:21:53.520 comprehend right don't worry you don't
00:21:55.600 have to get it at once from
00:21:57.640 understanding client and servers to apis
00:22:00.720 backend logic and databases there's a
00:22:03.320 lot of moving parts and if it feels
00:22:06.080 overwhelming don't worry take your time
00:22:09.360 revisit these Concepts and let them sync
00:22:11.799 in it's all a part of building a solid
00:22:14.200 foundation as a backend developer so
00:22:17.039 before we wrap up this course there's
00:22:19.480 one final piece to cover backend
00:22:22.600 architectures because how you design
00:22:24.840 your back end is just as important as
00:22:27.600 the tools you use so let's dive into
00:22:30.080 that
00:22:31.200 next now that we've covered how
00:22:33.520 databases and apis work let's zoom out
00:22:37.240 and talk about the big picture how to
00:22:40.120 structure your backend code the backend
00:22:42.520 architecture is all about the design and
00:22:45.320 the structure of your app it's not
00:22:47.840 rocket science but it is crucial for
00:22:50.480 building scalable maintainable systems
00:22:53.360 there are a few popular architectures
00:22:55.840 that developers follow depending on
00:22:57.799 their projects needs so let me break
00:23:00.000 them down the first and the most popular
00:23:02.240 one is the monolitic architecture in a
00:23:05.039 monolithic architecture all components
00:23:07.440 of your application are combined into a
00:23:09.640 single unified codebase makes sense
00:23:12.320 right everything's in one place and
00:23:14.559 therefore the back end handles
00:23:16.520 everything from user management to
00:23:18.799 business logic and database interactions
00:23:21.279 it's simple to develop and deploy and
00:23:23.720 it's easier to debug since everything's
00:23:25.679 in one place but it can get a bit messy
00:23:28.559 see if the app grows and scaling
00:23:30.679 specific parts of the app can be tricky
00:23:32.919 but as I said it has been the go-to
00:23:35.080 architecture for years and it's exactly
00:23:37.600 what I'll teach you how to build today
00:23:39.679 and the second type of backend
00:23:41.279 architectures are microservices in a
00:23:44.520 microservices architecture the
00:23:46.320 application is broken down into smaller
00:23:49.360 independent Services each service
00:23:52.320 handles a specific business function
00:23:54.919 like authentication payment or
00:23:57.440 notifications all separated and they
00:23:59.960 communicate with each other via apis so
00:24:03.159 no longer do you need just a single
00:24:05.080 front-end and backend connection through
00:24:06.720 an API now every single part of the back
00:24:09.640 end also needs to communicate through
00:24:11.520 its own apis making microservices grade
00:24:15.039 for large scale applications or
00:24:17.400 Enterprise systems where flexibility and
00:24:20.120 scalability are important and then
00:24:22.600 there's the serverless architecture that
00:24:24.559 lets you write code without worrying
00:24:26.840 about the underlying infrastructure
00:24:29.080 your cloud provider like AWS Lambda and
00:24:32.320 nowadays even versell handles
00:24:34.679 provisioning scaling and server
00:24:36.760 management for you so if you built a
00:24:38.679 full stack nextjs application you've
00:24:40.799 probably already worked with serverless
00:24:42.640 backends without even realizing it
00:24:45.159 serverless is perfect for startups rapid
00:24:47.919 prototyping or apps with spiky traffic
00:24:50.760 because you can very easily increase the
00:24:53.000 capacity that your server action can
00:24:54.960 handle and there are other architectures
00:24:56.720 too but these three are the most popular
00:24:59.399 and most widely used today so if You'
00:25:01.559 like me to cover microservices or
00:25:03.679 serverless architecture in detail
00:25:05.559 someday just drop a comment below and
00:25:07.960 let me know all right that's it for the
00:25:10.720 theory but before we dive into the
00:25:13.440 Hands-On part let's take a moment to
00:25:15.840 just appreciate what you've accomplished
00:25:18.200 we've covered a ton of ground from how
00:25:21.360 clients and servers communicate using
00:25:23.720 protocols and apis the different types
00:25:26.840 of apis and how they structured data to
00:25:29.760 how to build and manage databases and
00:25:32.159 interact with them using raw queries or
00:25:34.679 orms and finally you learned about
00:25:37.559 backend architectures and how to
00:25:39.559 structure real world applications that's
00:25:42.799 huge so what's next well now that you've
00:25:45.840 mastered the fundamentals it's time to
00:25:47.799 put that knowledge to work we're going
00:25:49.840 to build a subscription tracking AP a
00:25:53.279 real world project where you'll apply
00:25:55.600 everything you've learned so far from
00:25:57.360 setting up a mod ithc backend using no
00:26:00.320 jsn Express to connecting a mongodb
00:26:03.120 database securing your API with arcjet
00:26:06.399 and automating subscription tracking
00:26:08.440 with up stash workflows if you were
00:26:10.640 expecting a flashy eye-catching UI I
00:26:13.559 hate to disappoint but this video is all
00:26:15.840 about Jason in action so let me give you
00:26:18.799 a quick demo of the API you'll
00:26:22.399 build we'll use an HTTP client called
00:26:25.840 HTTP to test our API endpoints it's a
00:26:28.880 tool I recently discovered as an
00:26:30.520 alternative to postman and I've been
00:26:32.279 really enjoying it we have three main
00:26:34.559 endpoints one for users and one for
00:26:37.880 subscriptions and for each one of them
00:26:40.120 you'll create dedicated controllers or
00:26:42.919 in other words logic that makes them
00:26:44.919 work so starting off we have a regular
00:26:48.200 root route endpoint if you just make a
00:26:50.520 get request to Local Host 5500 you can
00:26:53.039 see welcome to the subscription tracker
00:26:54.799 API but now let's say that someone wants
00:26:56.760 to spam our API and bring your server
00:26:59.200 down well I'll teach you how to stop
00:27:01.039 them let's keep spamming our API and if
00:27:03.919 you do that for a couple of times very
00:27:06.320 soon you'll be hit with a rate limit
00:27:08.960 exceeded this means that you'll stop bad
00:27:11.120 users from making additional requests
00:27:12.960 and crashing your server on top of that
00:27:14.960 we'll also Implement a bot protection
00:27:17.159 system that will block them from
00:27:18.799 accessing your API all of that using
00:27:21.120 arcjet now let's test another API
00:27:23.320 endpoint so I can show you some of the
00:27:24.880 functionalities I'll make a post request
00:27:26.960 to API V one o sign up and I'll send
00:27:30.720 some user info as the request
00:27:33.159 body now if I click send you can see
00:27:36.520 that a new user has been created
00:27:38.000 successfully and the first thing we get
00:27:39.840 back in the data is a Json web token so
00:27:43.159 yeah we'll Implement that as well now if
00:27:45.200 you want to see your profile you can
00:27:46.840 make a get request to API V1 users and
00:27:51.559 then you have to enter the user ID which
00:27:53.559 we got from here so let me just do that
00:27:56.159 and remove the body and if I click Send
00:27:59.440 and if you make a request you'll get a
00:28:01.320 401 unauthorized which means that we
00:28:03.960 have a complete authorization system
00:28:05.720 implemented but now if you copy the JWT
00:28:08.640 that you got when creating your account
00:28:10.679 and paste it right here as the bearer
00:28:12.320 token and retry the request we get back
00:28:15.159 all the user info you can also get a
00:28:17.360 list of all the users just by going to
00:28:19.919 API V1 users but what matters most is
00:28:23.880 creating new subscriptions we can do
00:28:25.919 that by targeting our API V D1
00:28:29.240 subscriptions and then making a post
00:28:31.240 request to it and of course we have to
00:28:33.200 send the right request body where we
00:28:35.760 specify the name of the subscription the
00:28:38.159 price the currency frequency start date
00:28:41.440 and the payment method and let's create
00:28:43.960 it and in just a second a new
00:28:46.320 subscription has been created and before
00:28:48.840 we create this new subscription we also
00:28:50.880 have this special logic to autocalculate
00:28:53.279 the renewal date if it's missing so
00:28:55.320 what's happening behind the scenes is we
00:28:57.159 take the start date and then based on
00:28:59.320 the frequency we automatically calculate
00:29:01.840 the renewal date and don't get fooled
00:29:04.039 here if you pass any random values let's
00:29:06.799 say a random currency which doesn't
00:29:08.720 exist and try to create it you'll
00:29:11.440 immediately see a validation error which
00:29:13.760 means that you learn how to do full
00:29:15.360 validation of your apis but maybe the
00:29:17.919 most important thing is that as soon as
00:29:20.039 you create your subscription an
00:29:22.279 automated workflow kicks in sending you
00:29:24.600 multiple email reminders a week before
00:29:26.840 your renewal date that way you have
00:29:29.240 plenty of time to decide whether you
00:29:30.960 want to keep the subscription or cancel
00:29:32.840 it no surprises check this out I just
00:29:35.519 got an email that tells me exactly when
00:29:37.799 my subscription renews along with all of
00:29:39.880 my details and the payment method pretty
00:29:42.159 cool right and just like that you'll
00:29:44.159 receive the rest of the emails
00:29:45.519 automatically for every subscription you
00:29:47.559 create it's a real world solution to a
00:29:50.320 common problem no more stressing about
00:29:52.480 remembering when to unsubscribe or
00:29:54.519 manually setting your calendar reminders
00:29:56.679 just enter your subscription details
00:29:58.559 sit back and relax by the time you
00:30:01.120 finish building this amazing production
00:30:03.000 ready API you'll have learned how to
00:30:05.399 deploy scale and show it off to
00:30:07.760 potential employers so let's stop
00:30:09.960 talking and start building we'll first
00:30:12.559 need to set up a couple of things to
00:30:14.399 make all of this work this will allow us
00:30:16.559 to focus on coding without any
00:30:18.640 distractions first let's set up up stash
00:30:21.360 a serverless platform that allows us to
00:30:23.360 implement reddis scheduling and
00:30:25.679 workflows for example apps like dualingo
00:30:28.640 send automated emails to unboard new
00:30:30.799 users and remind them to keep learning
00:30:33.360 that's an onboarding workflow
00:30:35.200 subscription services like Netflix send
00:30:37.480 reminders about payment renewals before
00:30:39.519 the charge happens that's a subscription
00:30:41.720 workflow and today I'll teach you how to
00:30:43.880 build something similar a workflow that
00:30:46.279 sends reminders about upcoming
00:30:48.039 subscription payments that way you can
00:30:50.519 cancel subscriptions early and save
00:30:52.360 money instead of waiting until the last
00:30:54.240 minute of the last hour of the last day
00:30:56.600 and you may end up paying eventually
00:30:58.240 this is just one of the use cases of
00:31:00.279 what up stach allows us to do so let's
00:31:02.519 quickly set it up click the link in the
00:31:04.519 description to follow along and see
00:31:06.440 exactly what I'm seeing and then create
00:31:08.679 a new account once you do that we'll be
00:31:11.000 able to grab all of the environment
00:31:12.559 variables we need to make this work
00:31:14.639 we'll store them somewhere securely very
00:31:16.279 soon it's super simple to set up and the
00:31:18.679 implementation won't be any different
00:31:20.440 now the second thing we'll set up is
00:31:22.120 called arcjet once again the link is in
00:31:24.240 the description so just click it to
00:31:25.880 follow along as it'll allow you to to
00:31:28.039 secure your whole application within a
00:31:30.240 few lines of code in a few minutes
00:31:32.480 remember that raid limiting or bot
00:31:34.240 protection I was telling you about will
00:31:35.880 do it using arcjet so just sign up for
00:31:38.159 free and create a new project I called
00:31:40.559 mine subscription tracker and the last
00:31:43.120 thing to set up is the hosting for the
00:31:45.600 first time ever I'm going to go against
00:31:47.880 easy hosting services and I'll teach you
00:31:50.480 how to deploy your app on a hostinger
00:31:52.639 VPS a virtual private server is like
00:31:55.880 having your own computer on the cloud or
00:31:58.519 some other physical location in the
00:31:59.960 world but without the high cost of a
00:32:02.519 physical machine you'll get dedicated
00:32:04.480 resources full control and complete
00:32:07.360 customization allowing you to run
00:32:09.200 applications just the way you want and
00:32:11.720 it's not just for hosting apis you can
00:32:14.200 deploy full stack applications run
00:32:16.399 databases train AI models or set up Game
00:32:19.559 servers automate tasks or even
00:32:21.720 experiment with new technologies without
00:32:24.080 worrying it'll break your device but why
00:32:27.039 should you care hosting on a VPS might
00:32:29.960 sound like an Overkill but it'll
00:32:32.039 actually teach you Real World skills
00:32:34.639 that companies expect of you you'll get
00:32:36.720 hands-on experience with server
00:32:38.559 management database backup and Real
00:32:41.200 World deployments skills that most
00:32:43.440 tutorials skip because they're super
00:32:45.320 hard but also super needed also unlike
00:32:48.360 regular shared hosting where millions of
00:32:50.600 people host their apps on the same
00:32:52.279 server a VPS will give you much better
00:32:55.200 performance because it's only made for
00:32:57.120 you so so let's set it up you know very
00:33:00.279 well that I use hostinger for all of my
00:33:02.279 hosting needs they recently launched VPS
00:33:05.080 hosting for NOS applications so click
00:33:08.200 the link in the description to be able
00:33:09.639 to follow along and see exactly what I'm
00:33:11.960 seeing you'll get your own dedicated
00:33:14.080 server with lots of ram SSD storage
00:33:17.399 worldwide data centers and the Linux
00:33:19.840 operating system which will'll use to
00:33:21.880 set up our server and the best part it
00:33:24.440 costs less than a udemy course but
00:33:26.880 having the knowledge of the deploying
00:33:28.080 your apps on there Priceless for
00:33:30.679 potential Employers in our case the one
00:33:33.080 core plan is going to be more than
00:33:34.639 enough so click the link down in the
00:33:36.480 description and select it choose the
00:33:38.519 period of your hosting and enter a
00:33:41.399 coupon code since you're a part of JSM
00:33:44.320 hostinger is offering you an even bigger
00:33:46.799 discount continue with the payment and
00:33:49.120 I'll see you on the inside in your
00:33:50.720 dashboard you'll see some kind of an
00:33:52.200 onboarding and at the end of the day
00:33:54.480 you'll have your own machine running
00:33:56.480 somewhere in the world don't go through
00:33:58.320 the onboarding now because we'll go
00:34:00.320 through it together later on once we
00:34:02.440 develop our app and once we're ready to
00:34:04.600 host it okay wasn't too difficult right
00:34:07.360 let me know in the comments if you'd
00:34:08.719 like to set up things before getting
00:34:10.320 started like what we have done right now
00:34:12.480 or you prefer the usual process of
00:34:14.480 setting up things in between but for now
00:34:16.599 we have everything we need so let's dive
00:34:19.239 right into the code
00:34:28.440 to get started working on our amazing
00:34:31.359 subscription tracker API open up your
00:34:33.879 desktop and create a new folder you can
00:34:36.440 call it something like subscription Das
00:34:39.199 tracker once you do that open it up
00:34:41.800 within your code editor of choice any
00:34:44.119 editor is fine but in this course you'll
00:34:46.440 see me use webstorm it's more than an
00:34:48.320 editor it's an IDE and as of recently it
00:34:51.760 became completely free for
00:34:53.280 non-commercial use so once you're there
00:34:55.800 either open up a new dedicated terminal
00:34:58.119 window or you can use one built right
00:35:00.440 into your editor or IDE it'll look
00:35:02.560 something like this so let me show you
00:35:04.320 how you can very quickly spin up a new
00:35:06.520 express application we can do it by
00:35:08.760 using something known as an Express
00:35:10.520 generator simply run MPX express-g
00:35:14.440 generator and add a no view flag which
00:35:18.200 will skip all the front- end stuff since
00:35:19.920 we're focusing just on the back end also
00:35:22.000 add a d dgit flag and the name of the
00:35:25.160 app which is that slash meaning to
00:35:27.119 create it in the current repo and then
00:35:28.960 press enter and continue as soon as you
00:35:31.160 do that you'll see a couple of files and
00:35:32.880 folders that were created for you we'll
00:35:34.640 start from scratch so let's delete most
00:35:36.880 of the stuff that we don't need we can
00:35:38.480 delete the bin public and the routes
00:35:41.359 folders and clean up the contents within
00:35:43.960 the app as we'll create everything from
00:35:46.160 scratch first things first we'll need to
00:35:48.280 install something known as nodon so
00:35:51.280 let's run mpm install D- save-dev to
00:35:54.960 save it as a Dev dependency and say node
00:35:58.200 modon what nodemon does is it always
00:36:01.400 restarts your server whenever you make
00:36:03.400 any changes in the code I'll show you
00:36:05.280 how it works very soon to make it work
00:36:07.240 though we have to head over to our
00:36:08.960 package.json which was generated for us
00:36:11.560 when we ran that Express generator
00:36:13.599 within here you can change the name of
00:36:15.560 your app to something like subdub it's a
00:36:18.599 funny name that we chose for this entire
00:36:20.599 API and Below private above scripts you
00:36:24.200 can add something known as type of
00:36:27.079 module this will allow us not to use
00:36:29.400 that old require syntax but rather new
00:36:32.960 es6 import modules but rather new es6
00:36:37.119 plus Imports and we also have to change
00:36:39.760 some scripts first we can have a start
00:36:42.119 script which will simply run node app.js
00:36:45.839 and we can also have a Dev script make
00:36:48.839 sure to put it in double quoted strings
00:36:50.880 which will run the nodemon version of
00:36:52.720 that same app let me show you the
00:36:54.280 difference if I now head over into the
00:36:56.359 app.js and and add a conso log server
00:37:00.400 running if I open up the terminal and
00:37:03.079 Run mpm
00:37:05.079 start you'll see Server running but
00:37:07.880 immediately after it stops tracking it
00:37:10.560 so if I say server running on Local Host
00:37:14.040 5,000 nothing will happen I would need
00:37:17.440 to rerun it every time I make the change
00:37:19.760 to be able to see this difference but if
00:37:21.880 I now run it by using the mpm Run Dev
00:37:24.240 command using nodemon you'll see that
00:37:26.839 now it's tracking it and it says server
00:37:29.359 running on Local Host 5000 but if we
00:37:31.760 change it to something like 3,000 the
00:37:34.079 changes will be automatically reflected
00:37:36.319 in your
00:37:37.160 terminal great now that we got that out
00:37:39.760 of the way let's also make our
00:37:41.440 development process Smoother by setting
00:37:44.040 up a linter a linter will allow us to
00:37:46.359 keep our codebase clean so we can add
00:37:48.359 more code in a clean way as we continue
00:37:50.720 scaling our API we'll install the most
00:37:52.880 popular linter called es lent by running
00:37:55.640 MPX es Lent -- in it it'll ask you a
00:37:59.800 couple of questions such as how would
00:38:01.560 you like to use it in this case we're
00:38:03.480 going to use it to check syntax and find
00:38:05.880 problems next what type of modules are
00:38:08.119 we using we're using the modern import
00:38:10.560 export in this case we're not using a
00:38:12.359 framework so I'm going to select none of
00:38:14.000 these does your project use tab script
00:38:16.440 in this case it's going to be no if you
00:38:18.920 want to follow along and try to
00:38:20.599 implement tab script on your own that's
00:38:22.800 totally okay with me but for Simplicity
00:38:25.280 sake so we can focus on what matters
00:38:27.680 I'll say no our code will run in node so
00:38:30.800 follow the steps right here to toggle
00:38:33.000 off the browser and turn on the Node
00:38:36.040 it'll tell you that for this to work you
00:38:37.760 need to have a couple of dependencies so
00:38:40.079 say yes install them right now using mpm
00:38:43.520 and there we go the dependencies have
00:38:45.119 been installed and right now we have a
00:38:47.520 new eslint Doc config.js which will make
00:38:50.680 sure that we keep our code clean
00:38:52.520 depending on which editor you're using
00:38:54.400 you might have to head over to es length
00:38:56.920 settings and then turn it on manually by
00:38:59.200 pointing it to that specific package
00:39:01.520 same thing for the configuration file
00:39:03.640 and then we can run it on save this will
00:39:05.599 be a bit different for each editor but
00:39:07.520 don't worry about that too much with
00:39:09.200 that in mind we have now prepared our
00:39:11.200 codebase so we can start creating our
00:39:13.720 Express server so let's do that
00:39:17.839 next to start creating our Express
00:39:20.520 server let's head into the app.js and
00:39:23.839 let's make it work we can do it by
00:39:26.359 importing Express from Express and then
00:39:30.240 we are ready to initialize our app by
00:39:32.400 saying const app is equal to express and
00:39:35.800 then we call it as a function as soon as
00:39:37.440 you do that you're already ready to
00:39:39.800 create your first route you can do that
00:39:41.880 by referring to the app instance and
00:39:43.880 then calling the method of the HTTP call
00:39:46.400 you want to make it can be app. poost
00:39:49.280 app. put or in this case a simple
00:39:53.119 app.get then the first parameter you
00:39:55.720 pass into it is the path of where this
00:39:58.839 route will be reachable in this case
00:40:01.040 it'll be just forward slash meaning on
00:40:03.280 the homepage and as the second parameter
00:40:06.079 you can pass a callback function which
00:40:08.200 typically looks something like this an
00:40:09.720 arrow function where as arguments you'll
00:40:12.240 have access to the information about the
00:40:14.319 request and the response and you can put
00:40:16.760 them to use within this callback
00:40:18.240 function what we typically do when we
00:40:20.000 create a new API is just say rest. send
00:40:23.839 hello world or in this case we can do
00:40:26.720 something like like welcome to the
00:40:30.440 subscription tracker API even though
00:40:34.119 you've created your first route that's
00:40:36.119 not enough to be able to access it we
00:40:38.280 have to make our server listen for
00:40:40.240 requests trying to access specific
00:40:42.760 routes and you can do that by calling
00:40:45.040 the app. listen method and specify on
00:40:47.880 which Port you want to listen in this
00:40:50.000 case we can do something like Port 3000
00:40:52.839 and then you can define a callback
00:40:54.440 function which will be executed once you
00:40:56.319 run the application
00:40:57.960 and there you can just do a conso log
00:41:01.000 say something generic like server
00:41:02.680 running on Port 3000 or you can say
00:41:06.079 subscription tracker API is running on
00:41:11.359 HTTP
00:41:13.319 colon localhost colon
00:41:16.520 3000 this will expose the full URL of
00:41:19.520 where you can access your routes and
00:41:21.319 don't forget to run export default app
00:41:24.560 with that in mind let's give it a shot
00:41:26.240 and run our application I'll do it by
00:41:28.240 running mpm runev you can see that
00:41:30.920 nodemon has started and subscription
00:41:33.160 tracker API is running on Local Host
00:41:35.480 3000 you can click this URL right here
00:41:38.160 which will open it up in the browser and
00:41:40.560 you can see welcome to the subscription
00:41:42.200 tracker API which means that our server
00:41:44.480 is active great that's a good start but
00:41:47.480 in the next lesson let's set up our
00:41:49.599 environments so we can run this
00:41:51.440 application both locally and in
00:41:55.240 production to start setting up different
00:41:57.560 environments we need to have different
00:41:59.280 places where we can put and retrieve our
00:42:02.040 environment variables from so open up
00:42:04.240 your terminal stop your application from
00:42:06.119 running by pressing contrl C and then
00:42:08.319 run mpm install. EnV it's a package that
00:42:11.960 will allow us to retrieve our
00:42:13.440 environment variables so create a new
00:42:16.040 folder and call it
00:42:18.720 config and within config create a new
00:42:21.760 file called env. JS within it we can
00:42:25.640 import config
00:42:27.680 from the EnV package and then we can set
00:42:30.520 it up and then giving it a path pointing
00:42:32.800 to our EnV file so if we had just one
00:42:35.880 you could have said EnV like this this
00:42:38.800 will then extract all the environment
00:42:40.520 variables and then you can export them
00:42:42.200 from this file such as the port we're on
00:42:44.800 export const Port is equal to process.
00:42:49.079 EnV meaning that it's coming from the
00:42:50.599 environment variables file but now
00:42:53.200 here's the thing we don't want to Simply
00:42:55.319 have one environment variables file file
00:42:57.839 we want to have multiple for different
00:42:59.640 environments so let's actually make this
00:43:01.960 a template string and say that it'll
00:43:04.720 start withv dot but then it'll pull from
00:43:09.480 environment variables the process.
00:43:12.800 env. node EnV which is the node
00:43:16.240 environment or if that doesn't exist
00:43:19.800 it'll default to development and it'll
00:43:22.800 also end with local now let's fix this
00:43:25.960 typo looks like I said node end it was
00:43:28.200 supposed to be node EnV as an
00:43:30.200 environment and let's create those two
00:43:32.680 files in the root of the directory the
00:43:35.839 first one will be called the env.
00:43:39.520 production. loal and the second one will
00:43:42.800 be called env.
00:43:46.280 development. local within the
00:43:48.359 development local let's add a comment
00:43:51.079 you can add commments by putting the
00:43:52.520 hash sign and then on the new line you
00:43:54.880 can say Port is 5 ,500 this is a typical
00:43:59.280 backend boort we don't have to Define
00:44:01.160 anything in production for now we'll
00:44:02.800 just keep it on development so now we're
00:44:04.880 accessing this port from our environment
00:44:07.079 variables and we can also access the
00:44:09.880 node EnV if it exists by default it's
00:44:13.640 set to development anyway this way we
00:44:15.920 can very easily switch between
00:44:17.800 production and development envs without
00:44:20.319 overriding one another all we have to do
00:44:22.960 is change the node EnV right here in
00:44:25.680 production to be equal to well you can
00:44:28.680 guess it production and by default in
00:44:31.520 the development it's already set to
00:44:34.839 development great now let's go into our
00:44:37.720 app and let's use this port coming from
00:44:39.960 the config we can do that by importing
00:44:43.240 Port coming
00:44:45.119 fromc
00:44:47.880 config.js and now instead of manually
00:44:50.720 saying 3,000 right here we can change it
00:44:52.960 to port and we can also turn this into a
00:44:55.720 template string so when whenever the
00:44:57.359 port changes we can now say listening on
00:45:00.520 Port and we can add Port right here if
00:45:04.280 we now rerun our application by running
00:45:06.599 mpm run Dev you can see that we have the
00:45:09.640 subscription tracker API running on
00:45:11.640 Local Host 5500 which means that it's
00:45:14.280 successfully pulling the data from our
00:45:16.319 development environment and one thing
00:45:18.400 you must not forget to do is head over
00:45:21.000 into get ignore and scroll to the part
00:45:23.839 where we're ignoring different EnV
00:45:26.400 environment VAR variables and you have
00:45:28.319 to say
00:45:29.960 env. asterisk dolo which will make sure
00:45:33.960 to ignore all the EnV files and not push
00:45:37.400 them to GitHub later on once we do push
00:45:39.760 you never want to share those with the
00:45:41.200 internet great in the next lesson let's
00:45:44.200 set up our
00:45:46.200 routes to make your API serve its
00:45:48.880 purpose typically you needed routes or
00:45:51.520 endpoints that do their job that way
00:45:54.040 front-end apps or mobile apps or really
00:45:56.640 any one that you allow can hit those
00:45:58.599 endpoints to get the desired data so
00:46:01.440 let's go ahead and create a couple of
00:46:02.800 routes we'll do it in a super organized
00:46:05.480 way by first creating a new folder which
00:46:09.079 will call routes now you could have
00:46:11.280 totally had all your apps routes within
00:46:13.720 a single app.js file something like this
00:46:17.319 but of course not all routes are just on
00:46:20.000 liners they require more code and
00:46:22.800 specialized Logic for that reason we'll
00:46:25.599 separate our routes based on their
00:46:27.480 functionality we can do it with separate
00:46:29.359 files I'll create a new file and name it
00:46:33.079 o. routes.js this will be our first
00:46:36.920 separate router let's import router with
00:46:39.640 a capital R coming from Express and then
00:46:43.800 let's initialize it by saying const O
00:46:46.319 router is equal to router which we call
00:46:49.400 like this then similar to how you did
00:46:51.559 the app.get now you can do auth
00:46:54.920 router. getet or in this this case it'll
00:46:57.559 be a post route to slash sign- up and
00:47:03.200 then you already know it you can define
00:47:05.160 a callback function that'll be executed
00:47:07.599 once you call that API route in this
00:47:09.559 case I will simply return a string off
00:47:12.880 sign up but to return something from an
00:47:15.119 API it is not enough just to return it
00:47:18.160 you have to actually send it by using
00:47:20.280 the rest. send method and then pass over
00:47:23.520 the text as body and that response
00:47:26.079 typically won't just a single string
00:47:28.400 usually they're in a Json format where
00:47:31.359 you have something looks like this a
00:47:34.040 JavaScript object with different
00:47:36.000 properties right inside of it in this
00:47:38.920 case I can render a title and it can be
00:47:42.880 sign up we can duplicate this one two
00:47:45.240 times to create two other routes the
00:47:47.839 second one will be for sign in and the
00:47:50.520 title will say sign
00:47:52.319 in and the third one will be sign out
00:47:55.920 where we can say sign out of course we
00:47:58.720 haven't yet implemented actual
00:48:00.280 functionalities for these routes right
00:48:02.480 now they're just returning a piece of
00:48:04.319 text but very soon we can insert
00:48:06.599 functions that are going to deal with
00:48:08.359 the logic of whatever that route is
00:48:10.200 supposed to do right here for now we're
00:48:13.240 just creating the structure and at the
00:48:15.040 end you also have to export default that
00:48:17.880 router perfect these are auth routes so
00:48:21.839 now let's create another one I'll create
00:48:24.240 it for a user user
00:48:27.359 routes.js you know the drill we import
00:48:31.280 the router coming from Express then we
00:48:35.040 instantiate it by saying const user
00:48:37.520 router is equal to an instance of the
00:48:40.440 router and then we can Define the user
00:48:42.800 router and then different
00:48:45.040 routes for example we can have a route
00:48:48.520 that gets all users that will look
00:48:51.280 something like this user router. getet
00:48:54.400 slash we get the rec and the res and
00:48:57.119 then we simply return a response in this
00:48:59.720 case we can have an immediate return so
00:49:02.079 we can do something like res. send and
00:49:05.280 we can give it a title something like
00:49:08.359 fetch all users or we can be consistent
00:49:12.359 with our HTTP verbs so this will be get
00:49:15.880 all users and we can duplicate it a
00:49:18.160 couple more
00:49:19.960 times the second one will not get all
00:49:22.960 the users but it'll get the details of
00:49:26.400 aing singular user so in this case we're
00:49:29.160 using this special colon and then ID
00:49:31.839 property which stands for dynamic
00:49:34.160 parameter so for example you can have a
00:49:37.559 static parameter for SL users for
00:49:39.880 example which is always going to look
00:49:41.880 like this and whenever somebody hits it
00:49:44.240 they're going to get back all the users
00:49:46.680 but we also have Dynamic
00:49:49.280 parameters where it can look something
00:49:51.599 like this get users 1 2 3 or something
00:49:55.680 else and and every time it'll get
00:49:58.400 different user
00:49:59.760 details perfect so in this case we'll
00:50:02.440 say get user
00:50:05.280 details the third one can be a post
00:50:08.400 route under forward slash oh this one is
00:50:12.079 also just a forward slash so keep in
00:50:14.119 mind you can have multiple routes with
00:50:16.640 the same endpoint but they have to be
00:50:19.559 different HTTP verbs so one can be get
00:50:22.440 and the other one can be
00:50:24.160 post this one we'll use to to create a
00:50:28.200 new user and I think they're too close
00:50:30.200 together so let's give them some space
00:50:31.440 to
00:50:32.280 breathe we can also have another put
00:50:36.319 route puts are typically used for
00:50:38.960 updates so we have to know which user to
00:50:41.280 update so I'll also specify the dynamic
00:50:43.599 ID parameter and this one will update
00:50:47.200 the user by ID so update user and
00:50:50.480 finally the last one can be user router
00:50:53.400 delete and we also have to know which
00:50:55.599 user to delete so we'll also get that ID
00:50:58.960 and the title of that route will be
00:51:01.440 delete a user perfect finally let's
00:51:05.079 export default that user router and
00:51:08.119 we'll be able to use them very soon
00:51:09.920 within our app now that we know the
00:51:11.599 drill creating one more file will be
00:51:13.880 super simple let's just call it
00:51:16.559 subscription. routes.js once again we'll
00:51:20.440 import a new
00:51:22.520 router coming from Express we'll
00:51:25.400 instantiate it by saying con
00:51:27.160 subscription router is equal to the call
00:51:29.720 of the router and then we can Define
00:51:31.799 different routes by saying subscription
00:51:33.599 router Dot and then we can Define
00:51:36.520 different endpoint as well as the
00:51:38.280 Handler let's start with just forward
00:51:40.440 slash this one will rest. send a
00:51:45.760 title of get all subscriptions so if
00:51:51.000 we're being descriptive enough we don't
00:51:52.599 even have to add a comment of what
00:51:54.640 exactly this one does we can already
00:51:56.680 know just by looking at it and typically
00:51:58.599 if you're following well-written HTTP
00:52:01.160 rest API guidelines you'll always know
00:52:03.920 exactly what which route does if you
00:52:05.920 Google for rest API naming conventions
00:52:08.280 and best practices you'll very quickly
00:52:10.520 understand how it works make sure that
00:52:12.200 your URLs are named with nouns to
00:52:15.000 specify the resource instead of using
00:52:17.040 verbs so the uis themselves shouldn't
00:52:20.240 indicate any credit operations you
00:52:22.280 shouldn't say create items get employees
00:52:24.760 update prices and so on you should do
00:52:26.960 what we're doing in this video where
00:52:28.599 you're going to have users or
00:52:30.359 subscriptions and then you can either
00:52:32.400 have a specific Item ID or you can just
00:52:34.920 have for/ subscriptions and get all of
00:52:37.240 them same thing here use pluralized
00:52:40.200 nouns for resources like items or
00:52:43.040 employees that's bad you always want to
00:52:45.520 use plural similar to what we're doing
00:52:47.799 with users or subscriptions use hyphens
00:52:50.880 to connect different words together and
00:52:53.079 so on and so forth and so on but I'm
00:52:55.880 already teaching you all of those
00:52:57.280 practices so you don't really have to
00:52:58.799 think about them just learn how to do
00:53:00.599 things properly oh and you might wonder
00:53:03.160 like not that long ago we already had a
00:53:06.200 user route that was a get route that
00:53:09.280 started with a forward slash but here we
00:53:11.640 have a subscription route which can also
00:53:13.599 be doget and also the forward slash so
00:53:17.040 wouldn't those routes Clash well not
00:53:19.319 really let me show you why I will export
00:53:22.559 default this subscription router so we
00:53:25.160 can use it within the app as a matter of
00:53:28.599 fact we'll import all of these routes
00:53:30.799 right within our appjs you don't have to
00:53:33.319 explicitly code them within here but
00:53:35.440 they definitely have to be imported here
00:53:37.400 because the app is the center of your
00:53:39.680 application so let's import the user
00:53:42.559 router coming from routes SL user.
00:53:48.000 routes.js and let's also duplicate two
00:53:51.040 times and import the second router which
00:53:54.319 is the O router coming from routes off
00:53:57.920 routes.js and finally we have a
00:54:01.960 subscription router which is coming from
00:54:04.640 routes subscription. routes.js
00:54:08.520 once you import them you have to put
00:54:11.119 them to use right here below the app we
00:54:14.319 can say app.use and we typically use the
00:54:17.720 use keyword with something like
00:54:19.440 middleware where you want to maybe tell
00:54:21.200 your application that it's going to be
00:54:22.640 using Json but we also use use when you
00:54:26.079 want to say which routes you want to use
00:54:29.280 so in this case we can say
00:54:32.160 app.use SL
00:54:34.160 API
00:54:36.200 slv1
00:54:38.079 SLO and then here we can render the O
00:54:42.240 router this means this means that you
00:54:45.000 can get to this signup by first heading
00:54:49.040 over to for SL API
00:54:52.400 slv1 SLO and then sign up like this
00:54:57.680 hopefully that makes sense so you're
00:54:59.640 prepending whatever is here and then
00:55:02.400 you're attaching these additional routes
00:55:04.440 to it in a similar way we can
00:55:07.240 add the users keep in mind good practice
00:55:10.799 to keep it plural and then we can also
00:55:13.599 add the subscriptions this is going to
00:55:15.839 be the user router and finally we're
00:55:18.839 going to have the subscription
00:55:22.280 router and the answer is that these two
00:55:24.960 don't Clash because this is API V1 users
00:55:29.559 and this one is API V1
00:55:32.920 subscriptions perfect now let's finalize
00:55:35.680 our subscription routes and then we'll
00:55:37.359 be able to make calls to our API so I
00:55:39.599 can show you how that works for now I'll
00:55:41.559 duplicate it a couple of times and
00:55:43.680 create some space just so we can see
00:55:45.200 what's happening the second one will get
00:55:47.280 subscription by ID so it'll still be get
00:55:50.480 but it'll have a colon ID right here and
00:55:53.240 it'll be get subscription
00:55:57.720 details the third one can be a post
00:56:00.680 which we'll use to create a subscription
00:56:03.839 so this will be a create subscription
00:56:06.920 after that we also need to update the
00:56:09.200 subscription so we'll say put based on a
00:56:12.440 specific ID update a
00:56:17.000 subscription after that we need to be
00:56:19.079 able to delete a subscription we're
00:56:21.280 basically dealing with crud
00:56:22.680 functionalities right here a
00:56:24.440 foundational element of every sing s Le
00:56:26.559 API out there you need to be able to
00:56:29.599 delete create or read or update
00:56:33.039 literally anything out there and on top
00:56:35.480 of all of these basic credit operations
00:56:37.839 we'll also need to get all the
00:56:39.400 subscriptions belonging to a specific
00:56:41.640 user so we can make it something like
00:56:44.760 slash user forward slash and then ID
00:56:48.520 that way we can try to extract all the
00:56:51.440 subscriptions of a specific user so get
00:56:54.319 all user subscriptions
00:56:57.000 we'll also have another put right here
00:56:59.599 below which will cancel a user
00:57:01.920 subscription so this one will go to SLC
00:57:05.240 colon ID slanc and we'll call it
00:57:09.559 cancel subscription and finally we'll
00:57:12.440 create one more route which will get us
00:57:16.119 all
00:57:17.440 upcoming renewals that way we can know
00:57:20.599 which subscriptions are coming soon so
00:57:22.520 I'll say get upcoming renewals perfect
00:57:27.319 this seems like a lot of routes but
00:57:29.960 they're nicely contained within their
00:57:31.799 own file and we're importing them here
00:57:33.920 so we can actually use them so what do
00:57:36.280 you say that we put it to the test our
00:57:38.240 application is running on Local Host
00:57:40.440 5,500 so if you open it up you'll see
00:57:43.079 that it works and if we try to maybe get
00:57:45.880 all subscriptions that's going to be
00:57:47.920 under API V1
00:57:51.079 subscriptions so we can append that to
00:57:53.640 Local Host 5000 URL and you can see that
00:57:57.240 my browser automatically turns this into
00:57:59.720 a Json format and we even have this nice
00:58:02.599 pretty print option which returns it in
00:58:04.799 a nicer format title get all
00:58:07.720 subscriptions if we had to V1
00:58:11.280 users you can get all users but these
00:58:15.359 Json outputs are never meant to be read
00:58:18.000 by a user on a site I mean sure you can
00:58:21.039 make get requests using the browser
00:58:23.240 because when searching for a website a
00:58:25.319 browser automat automatically makes a
00:58:26.799 get request and outputs the HTML for you
00:58:29.599 in this case that response is Json data
00:58:32.760 but to test other types of HTTP requests
00:58:36.000 you'll need an HTTP client like Postman
00:58:40.000 or insomnia or even modern lightweight
00:58:43.480 HTTP clients like HTTP which has a very
00:58:46.839 simplistic interface but still gets the
00:58:49.160 job done and there's also another one
00:58:51.000 which I found to be very popular which
00:58:52.880 is called simply Bruno allowing you to
00:58:55.319 make all sorts of different HTTP
00:58:57.079 requests nowadays there's also HTTP
00:58:59.760 clients built right into your editor so
00:59:02.359 just Google the name of your editor and
00:59:03.880 try to find a package that does that for
00:59:05.760 you I really needed something simple and
00:59:08.680 HTTP delivered it's just a free download
00:59:12.079 I installed it on my device and now I
00:59:14.720 can make get requests similar to what my
00:59:17.400 browser can do but I can also very
00:59:20.079 easily switch it to a post request for
00:59:22.319 example and if I try it you can see that
00:59:25.200 we get a title on off create
00:59:26.839 subscription which means that we have
00:59:28.480 now successfully hit not only our get
00:59:30.960 routes but also the create routes we
00:59:34.599 know that because we got this Json back
00:59:37.000 right from our API create subscription
00:59:39.960 in the next lesson let's set up our
00:59:41.799 database which will make us one step
00:59:44.000 closer to implementing real
00:59:45.880 functionality to store and retrieve
00:59:50.240 subscriptions now is the time to set up
00:59:52.440 our database you could use something
00:59:54.359 older like postgress or or maybe
00:59:56.559 something modern like neon which is a
00:59:58.839 serverless platform that allows you to
01:00:00.640 host postr databases online then you
01:00:03.520 could hook it up with an orm like
01:00:05.200 drizzle and it would all work but in
01:00:07.680 this course I'll use mongodb Atlas
01:00:10.680 allowing us to very easily create a
01:00:12.799 database and host it on the cloud
01:00:15.000 completely for free now it is important
01:00:17.119 to mention that up to this point this
01:00:19.160 course was completely database agnostic
01:00:21.799 which means that the concepts we learned
01:00:23.760 could be applicable to any database and
01:00:26.240 if you wanted to use SQL that's totally
01:00:29.240 okay I would still say follow through
01:00:31.440 with the video watch me Implement
01:00:33.440 mongodb in a non-sql database see how it
01:00:37.200 all works and then later try to modify
01:00:40.079 it on your own and switch it to an SQL
01:00:42.680 database you'll learn so much more that
01:00:45.079 way or maybe in the future I split this
01:00:47.240 video in two and build it with other
01:00:49.280 databases in mind as well who knows but
01:00:52.599 for the time being head over to mongodb
01:00:54.839 Atlas and click try free create your
01:00:57.280 account and once you're in the dashboard
01:00:59.720 create a new project name it something
01:01:02.240 like
01:01:03.599 subscription
01:01:05.559 tracker click next make yourself the
01:01:08.559 project owner and when you click create
01:01:10.760 it'll take some time and then you'll
01:01:12.599 have to create your database cluster
01:01:14.720 basically your database click create and
01:01:17.960 choose m0 which is the free version
01:01:20.559 which gives you about half a gigabyte of
01:01:22.160 storage and trust me that is more than
01:01:24.240 enough for storing Json information the
01:01:26.839 rest of the option is okay so just click
01:01:28.960 create deployment now this is very
01:01:31.200 important you can choose your username
01:01:33.599 I'll do JSM right here and then you'll
01:01:36.119 also have to choose your password make
01:01:38.119 sure to write this password down as
01:01:39.880 you'll need to use it later on within
01:01:41.359 the code click create and choose a
01:01:43.319 connection method in this case we'll
01:01:45.280 connect through a mongodb driver like
01:01:47.839 node.js so choose the first option and
01:01:50.799 copy the installation command mpm
01:01:53.200 install mongodb back in the code you can
01:01:56.279 open up a new
01:01:58.119 terminal and run mpm install
01:02:02.119 mongodb and let's also install
01:02:05.599 which is an orm for mongodb allowing you
01:02:08.119 to more easily create your database
01:02:10.039 models and schemas and press enter while
01:02:13.200 that is installing let's wait for a
01:02:15.240 cluster to provision basically means
01:02:17.440 your database is setting up we can go
01:02:19.640 back and then click drivers one more
01:02:21.599 time to see if it's provisioned if not
01:02:23.839 let's give it a minute once that is done
01:02:25.880 you'll be given your connection string
01:02:27.559 which you can copy and add to your
01:02:29.240 codebase but make sure to replace the DB
01:02:31.839 password with the original password for
01:02:34.119 your username so back into the code let
01:02:36.720 me head over to our EnV development
01:02:39.039 local and add new environment variables
01:02:42.279 for our database I'll call it DB URI and
01:02:47.240 simply paste the string that I just
01:02:48.960 copied right here mongodb SRV JSM and
01:02:52.960 for my password I chose just JSM as well
01:02:55.880 well hopefully you chose something more
01:02:57.520 secure now we can head over into config
01:03:00.599 envs and we can also export con the DB
01:03:04.240 URI right here once you've done that
01:03:07.079 create a new
01:03:08.440 folder which we can call
01:03:13.480 database and within it create a new file
01:03:16.480 called mongod db.
01:03:20.440 JS within it we can import Mongoose
01:03:23.880 coming from mongoose
01:03:26.760 and we can import the environment
01:03:28.200 variables which we need so that's going
01:03:30.000 to be the DB URI as well as node EnV
01:03:34.440 coming
01:03:35.480 fromc
01:03:38.079 config.js we can first check if there is
01:03:41.760 no DB
01:03:44.240 URI then we can throw a new
01:03:47.079 error something like throw new error
01:03:50.960 please define the mongodb URI
01:03:53.079 environment variable inside v. local and
01:03:57.559 of course this is
01:03:59.760 env. either
01:04:02.880 development or production local so I'll
01:04:06.079 make it super specific just so we know
01:04:08.039 that it has to be EnV do and then
01:04:10.559 development production.
01:04:12.400 local if we pass that if statement that
01:04:15.400 means that we are ready to connect so
01:04:17.200 let's say const connect to database and
01:04:21.799 that'll be equal to an asynchronous
01:04:23.640 function which has a try and a catch
01:04:27.640 Block in the catch we get an error and
01:04:30.640 obviously something went wrong so let's
01:04:33.279 simply consol log that error saying
01:04:35.680 error connected to database show that
01:04:37.960 error and then exit the process with a
01:04:41.000 code of one which means failure but
01:04:43.960 we're trying to make something go right
01:04:45.760 and that something is a wait mongus do
01:04:49.760 connect and we simply want to connect to
01:04:52.359 this specific DB URI which we got from
01:04:54.839 mongodb app
01:04:56.400 and I believe that's it we don't have to
01:04:58.319 pass anything else now we have to call
01:05:00.839 this function from somewhere so let's
01:05:02.839 export it by saying export default
01:05:05.000 connect to database and let's head over
01:05:07.760 into the
01:05:09.720 app.js where do you think we'll call it
01:05:12.680 well right here within app. listen as
01:05:15.279 soon as we start our application on
01:05:17.440 Local Host something we can also try to
01:05:21.200 connect to database make sure to import
01:05:25.200 this function from the top a waited
01:05:28.559 because it is an asynchronous function
01:05:30.839 and therefore you have to make this one
01:05:32.319 asynchronous as well if you've done that
01:05:34.440 correctly and if you head over into
01:05:36.720 connect to
01:05:38.200 mongodb alongside this await once we
01:05:42.200 pass it we can also conso log something
01:05:45.640 maybe something like conso logged
01:05:47.920 connected to database in node EnV
01:05:51.760 mode so this is going to be either
01:05:53.839 production or development it's a so now
01:05:56.240 if you open up your terminal you can see
01:05:58.240 subscription tracker API running on
01:06:01.079 connected to database in undefined mode
01:06:03.680 oh that's definitely not good but I
01:06:05.720 think I know why that is we have only
01:06:08.599 defined it in
01:06:09.960 production but I'll also add it to
01:06:12.160 development right here under environment
01:06:15.000 and I'll say no dnv is equal to
01:06:17.680 development if I do it like that make a
01:06:20.359 change to any file and save it'll say
01:06:23.520 connected the database in development
01:06:25.160 mode which is exactly what we wanted
01:06:28.200 great now that we have the routes and
01:06:30.200 the database let's go ahead and create
01:06:32.559 some
01:06:34.720 models models in our application let us
01:06:37.760 know how our data is going to look like
01:06:40.200 so let's define it right here in the
01:06:42.319 root of our application by creating a
01:06:44.559 new folder and let's call it models and
01:06:47.599 to keep everything organized we'll
01:06:49.440 create multiple files such as user.
01:06:52.480 model. JS as well as a subscript
01:06:56.920 destion model. JS I think you can
01:07:00.400 already start seeing the practice we
01:07:02.079 have we create separate routes separate
01:07:05.480 models and soon enough separate
01:07:07.720 controllers for every one of these parts
01:07:10.559 of our API once you understand the gist
01:07:12.680 of it you'll know how it all works so
01:07:15.720 let me show you how to create that model
01:07:17.960 we can first import mongus coming from
01:07:21.680  and then we can define a user
01:07:24.559 schema const user schema is equal to new
01:07:28.680 mongus do schema to which you can pass
01:07:32.640 an object that allows you to Define how
01:07:35.640 a specific model is going to look like
01:07:38.119 we can give each user a name and then
01:07:40.160 make it an object to Define more
01:07:41.799 information about that name for example
01:07:44.400 it'll be of a type string and alongside
01:07:47.319 required will also pass an array and say
01:07:50.880 true but we can also Define an error
01:07:54.640 message if it's not there by saying
01:07:56.799 something like username is required that
01:07:59.799 way if something goes wrong in the code
01:08:02.160 we'll know why it is wrong because we're
01:08:04.480 missing a username we can also trim it
01:08:07.119 by saying trim true if we have some
01:08:09.000 empty spaces in there and we can give it
01:08:11.240 a Min length of something like two
01:08:13.680 characters and a max length of about 50
01:08:17.238 what else does the user need well we can
01:08:19.479 have an email right here and it'll be
01:08:21.960 very similar with a type of string
01:08:24.880 required to true user email is
01:08:27.960 required unique in this case will be
01:08:30.319 said to true because only one user can
01:08:32.759 have that specific email with a trim to
01:08:35.960 true we can also make lowercase to be
01:08:39.000 true as well because email tend to be
01:08:41.040 lowercase and bear with me I'll also
01:08:43.560 show you how to write a very quick
01:08:45.839 regular expression to check for emails
01:08:48.960 we can say that this specific parameter
01:08:51.920 has to match the following format as you
01:08:54.960 can see my co-pilot wrote it for me here
01:08:57.600 nobody writes regular Expressions by
01:08:59.439 hand today it's just a forward slash
01:09:02.520 backward slash s+ at sign backwards s+
01:09:06.399 whatever it is basically it means that
01:09:09.000 we'll start with a
01:09:10.960 string followed by an add sign some more
01:09:14.279 string signs for the domain followed by
01:09:16.520 a DOT and then some more characters for
01:09:18.880 the domain name extension something like
01:09:21.080 contact ajs mastery. proo great and
01:09:24.880 finally a user also has to of course
01:09:27.679 have a password which will be of a type
01:09:30.238 string required will be set to true and
01:09:33.920 we'll say that the user password is
01:09:35.719 required we won't be trimming or messing
01:09:38.279 with the password in any way but I will
01:09:40.679 set a Min length to about six characters
01:09:43.279 finally we'll go a bit down not below
01:09:46.640 the password but outside of the schema
01:09:49.359 definition and I'll set timestamps to
01:09:51.719 True which means that alongside these
01:09:53.719 properties we'll also have created ad
01:09:56.440 and updated ad Fields so we know when
01:09:58.800 that user has been created or modified
01:10:01.440 perfect with that in mind we can create
01:10:03.679 a new model off of that schema by saying
01:10:06.880 cons user is equal to dood with
01:10:10.360 the name of user and then we pass over
01:10:13.360 the user schema we want to create that
01:10:15.199 model off of models typically start with
01:10:18.400 a capital letter and don't forget to
01:10:20.960 export default. model off of which we'll
01:10:24.199 then be able to create instances of that
01:10:26.520 model such as different users so we can
01:10:29.159 have a user that's going to look
01:10:30.960 something like this it'll of course have
01:10:33.320 a name of John Doe email I guess of
01:10:38.040 Johnny
01:10:39.679 at
01:10:41.520 email.com and finally a password of
01:10:44.159 password we'll get to there by using the
01:10:47.159 user. create method we'll get to there
01:10:50.880 by doing something like
01:10:52.679 user. create
01:10:55.440 and then passing over the
01:10:57.080 information but more on that later for
01:10:59.560 now it's important that we have this
01:11:01.040 model now that we know the basis of
01:11:02.960 creating mongodb models let's create one
01:11:05.440 for the subscription just to recap our
01:11:07.960 subscription will have a bit more Fields
01:11:10.440 as it's the primary part of our
01:11:12.199 application the main model schema and
01:11:15.679 document so let's import Mongoose from
01:11:20.000  and let's define our schema by
01:11:23.159 saying con subscription schema is equal
01:11:25.760 to new mongu schema I'll also
01:11:29.560 immediately add the time stamps is true
01:11:32.320 at the bottom and now we can give it all
01:11:34.760 sorts of different fields I'll start by
01:11:37.719 giving it a name which will be of a type
01:11:41.440 string required will be set to true and
01:11:45.480 I'll say subscription name is required
01:11:48.960 I'll also trim
01:11:51.080 it and I'll give it a Min length of
01:11:54.440 about two and a max length of about 100
01:11:58.480 after the subscription name which can be
01:12:00.199 something like Netflix we'll have to
01:12:02.280 have a price of that subscription this
01:12:05.480 one will be of a type is number and
01:12:08.480 it'll also have a required property to
01:12:10.560 True set to subscription price is
01:12:13.400 required with a Min value of zero and we
01:12:17.360 can also add kind of like a message
01:12:19.719 price must be greater than zero after
01:12:22.920 that we can Define the currency that it
01:12:25.440 is in this is totally optional because
01:12:27.960 you might be using just a single
01:12:29.360 currency but in case you want to add it
01:12:31.840 you can make it of a type string but
01:12:34.080 then a cool thing is that you can Define
01:12:35.880 it as an enum of one of these properties
01:12:40.000 like USD Euros British pounds or so on
01:12:43.520 you can add your currency right here and
01:12:45.840 then when trying to create a new
01:12:48.080 subscription It'll ask you for the
01:12:49.800 currency as well I'll make it default to
01:12:52.800 USD another very important part of of
01:12:55.280 our subscription is the
01:12:57.360 frequency how often are you getting
01:12:59.600 charged for that subscription and this
01:13:02.000 will be of a type string and this will
01:13:05.120 be an enum of daily weekly monthly or
01:13:08.639 yearly we can also have a category for
01:13:11.639 that
01:13:12.600 subscription just so we know where we're
01:13:14.520 spending the most and it'll be of a type
01:13:18.480 is
01:13:20.520 string and we can also make it an enum
01:13:23.960 of something like sports news
01:13:26.800 entertainment lifestyle technology
01:13:29.000 Finance whatever it is right you get the
01:13:31.639 idea and it'll make this one
01:13:35.440 required set to True let's also Define a
01:13:38.600 payment method which will be of a type
01:13:41.159 string required to true and trim to true
01:13:44.719 as well and let's define a status of
01:13:47.239 that
01:13:47.920 subscription which will be of a type
01:13:50.280 string it'll be an enum of either active
01:13:55.800 or
01:13:57.280 cancelled or expired and the default
01:14:00.719 will be set to
01:14:02.600 active now that we have all of these
01:14:05.159 base properties we also might want to
01:14:07.560 know when is the start date of that
01:14:09.719 subscription so I'll say start date will
01:14:12.719 be of a type date it'll be set to
01:14:15.719 required to true and we can also
01:14:19.159 validated by saying validate to which
01:14:23.040 you can pass an object where you can
01:14:25.639 define a validator function so that'll
01:14:28.440 look something like this you can define
01:14:30.840 a new callback function where you get
01:14:32.600 the value and then you can check if
01:14:35.239 value is lower than or equal to new date
01:14:39.199 which is basically the current date and
01:14:41.239 if that is the case you can provide a
01:14:43.520 message something like start date must
01:14:45.960 be in the past because you cannot create
01:14:49.120 subscriptions in the future and we can
01:14:50.880 duplicate this entire start date but
01:14:53.800 this time I'll call it renewal date type
01:14:56.800 of date required to true and we'll
01:14:59.159 validate it but I'll switch it around
01:15:01.840 the value must be greater than the start
01:15:05.199 date and a pretty cool thing is we're
01:15:06.840 not comparing it with date do now we're
01:15:08.880 comparing it with this dot start
01:15:13.280 date this of course referring to our
01:15:15.960 model and I'm not sure whether Arrow
01:15:18.639 functions will work with this we might
01:15:21.520 actually need to wrap it in an actual
01:15:23.760 function so can say validator is a
01:15:26.679 function no Arrow Signs right here
01:15:29.360 rather it's a good old function where
01:15:31.639 you open up a function block and then we
01:15:34.080 can return this value perfect and we can
01:15:38.199 say something along the lines of renewal
01:15:41.440 date must be after the start date and
01:15:44.239 the last missing piece of the puzzle is
01:15:46.920 the user that actually subscribed to
01:15:49.239 that subscription so we can say
01:15:52.320 user and it'll be of a type
01:15:55.440 mongus do schema. types doob ID so we're
01:16:00.880 actually accepting the ID which is going
01:16:03.480 to be a reference to the user model that
01:16:07.080 we have already created right here we
01:16:09.840 only need to get its ID required will be
01:16:11.960 set to true and we'll also set index to
01:16:15.040 True which will optimize the queries by
01:16:17.840 indexing the user field don't get me
01:16:19.960 wrong if this is your first API that
01:16:21.800 you're creating well this definitely is
01:16:23.800 a larger model it has a lot of
01:16:25.840 interesting stuff right here from
01:16:27.719 strings to numbers to enums some with
01:16:31.280 default values others with required
01:16:33.800 values and even some more specific
01:16:36.360 properties where we're trying to
01:16:37.800 validate the value that's being passed
01:16:39.719 in by using the validator function we're
01:16:41.840 not keeping it super simple I got to
01:16:44.080 keep you on your toes so you're always
01:16:46.120 learning something and then we also have
01:16:47.800 references pointing to other models in
01:16:49.600 the database now we'll improve it just a
01:16:51.880 tiny bit more by creating a function
01:16:54.920 that will happen before each one of the
01:16:57.280 documents is created it looks something
01:16:59.520 like this subscription
01:17:03.000 schema.
01:17:04.880 pre and we'll run it pre- saave so this
01:17:09.360 next function where you get the next as
01:17:11.520 an argument will be called before we
01:17:13.960 save that document oh and we're using
01:17:15.920 the function keyword right here so we
01:17:17.840 don't need the arrow sign what this
01:17:21.040 function will do is it'll autocalculate
01:17:26.280 the renewal date if missing so if we
01:17:29.600 don't provide the renewal date therefore
01:17:32.480 we don't have to make it required it
01:17:34.400 should autocalculate it based on the
01:17:36.520 start date and the renewal period so we
01:17:39.600 can say if no this. renewal date in that
01:17:43.600 case we can Define different renewal
01:17:45.600 periods like con renewal periods is
01:17:50.120 equal to an object where daily will be
01:17:53.400 set to one weekly 7 monthly to 30 and
01:17:56.679 yearly to 365 then we can set up the
01:17:59.600 renewal date to look something like this
01:18:02.360 this. renewal date is equal to new date
01:18:04.920 from start date so now we have just made
01:18:06.960 it a start date but now we have to
01:18:09.000 actually increase it by saying this.
01:18:11.560 renewal
01:18:13.600 date. set date it will be equal to this.
01:18:17.920 Renewal dat. getet date Plus renewal
01:18:22.000 period of this do frequency
01:18:25.400 might be a bit confusing but basically
01:18:27.159 what we're doing is we're adding this
01:18:29.400 number of days based on the frequency
01:18:31.719 that we pass in so for example if we
01:18:34.520 started it on January 1st and the
01:18:38.199 frequency is something like monthly in
01:18:41.560 that case it'll be 30 days which will
01:18:44.600 end up being January 31st make sense
01:18:48.520 hopefully so we can go outside of this
01:18:50.719 if and we can also auto update the
01:18:53.440 status if renewal date has passed so
01:18:57.920 that'll look something like this if
01:18:59.840 this. renewal date is lower than new
01:19:03.520 date which is the current date then we
01:19:05.719 simply set the this dat status to
01:19:07.480 expired after we do everything we can
01:19:10.199 simply call next and make it proceed
01:19:12.400 with the creation of that document in
01:19:14.040 the database so in this case you not
01:19:16.920 only learned how to create a model that
01:19:19.159 has all sorts of different properties
01:19:21.719 you also learn how to validate those
01:19:23.679 properties before they're entered and
01:19:26.000 you'll learn how you can call specific
01:19:28.199 actions before a document is saved
01:19:31.880 perform additional logic and then modify
01:19:34.760 delete or update properties on that
01:19:37.239 instance based on external criteria the
01:19:40.679 lack of some properties like the renewal
01:19:42.360 date and so on perfect finally let's
01:19:46.120 create a model out of that schema and
01:19:49.320 let's export it with that we're done
01:19:51.840 with the two primary models the user
01:19:53.840 model and the subscription model and as
01:19:56.440 soon as we authenticate our user we'll
01:19:58.320 be able to put it to the test where
01:20:00.320 we'll be able to attach different
01:20:02.080 subscriptions to different users before
01:20:05.040 we do that though let's improve the
01:20:06.880 global air handling of our application
01:20:09.120 because as it's growing we might start
01:20:11.199 to make some mistakes in our code so
01:20:13.440 it's nice to have a centralized aor
01:20:15.400 handling system to track all of those
01:20:18.960 errors let's create a global air
01:20:22.000 handling metalware that'll nicely alert
01:20:24.320 us whenever something goes wrong we can
01:20:27.000 do that easily by creating a new folder
01:20:30.040 called middle Wares and within it we can
01:20:32.800 create a new file called error.
01:20:35.760 middleware
01:20:37.360 DJs and within it we can Define it just
01:20:40.040 as a regular JavaScript function const
01:20:42.719 error middleware is equal to a function
01:20:47.199 that looks like this now not just airor
01:20:50.480 middleware but any kind of middleware in
01:20:53.360 node.js or or any other backend software
01:20:56.400 typically looks like this alongside the
01:20:59.520 request and the response you get two
01:21:01.440 additional things the information that
01:21:03.840 happened before the request and then
01:21:06.719 what happens after when you're ready to
01:21:08.920 proceed to The Next Step let me explain
01:21:10.840 what I mean by this like let's say that
01:21:13.800 we have the ability to create a new user
01:21:17.560 in a way when we had a subscription
01:21:19.600 model in the previous lesson this
01:21:21.960 subscription scheme at that pre was
01:21:24.280 actually in a way of middleware because
01:21:26.560 it happened before something and then
01:21:29.120 told us hey now we're ready to move to
01:21:31.239 the next step so let's say that you're
01:21:33.719 trying to create a subscription create a
01:21:37.920 subscription then we have a new
01:21:39.800 middleware that maybe checks something
01:21:42.520 like check for Renewal date and then you
01:21:45.520 can have as many middle Wares as you
01:21:47.639 want we can have another middleware
01:21:49.840 maybe this one will actually check for
01:21:52.960 errors and then only
01:21:55.120 when both of these middle Wares call
01:21:57.120 their next status we are actually
01:21:59.960 navigated over to the controller which
01:22:02.159 handles the actual logic of creating a
01:22:04.719 subscription hopefully that makes sense
01:22:07.159 basically some blocks of code that are
01:22:09.679 executed before or after something
01:22:12.480 allowing us to intercept what is
01:22:14.400 happening so let's open up a try and
01:22:16.760 catch block and in the catch we get the
01:22:20.040 error and we'll simply send that error
01:22:22.320 over to the next step to let us know
01:22:24.360 that that the error actually happened
01:22:26.679 but in the tri block we'll actually try
01:22:28.600 to decipher that error to let us know
01:22:30.920 exactly what the issue is so I'll say
01:22:33.719 let error is equal to and I'll create a
01:22:37.840 new object and D structure the error
01:22:40.560 that we're getting through
01:22:41.880 props then I'll set the error message to
01:22:44.880 be equal to ER r. message and I'll conso
01:22:49.800 log the error to the dev so console.
01:22:52.960 error and then we put pass the error
01:22:55.920 right here just so we know what's
01:22:59.800 happening after that we can try to
01:23:02.120 figure out a type of error maybe it is a
01:23:05.840  bad object ID this is a very
01:23:09.239 common error that we get when working
01:23:10.840 with and
01:23:12.159 mongodb this one would happen if we have
01:23:14.800 a cast error if that is the name so if
01:23:17.880 that is the name we can create a new
01:23:20.159 message const message is equal to
01:23:24.800 resource not
01:23:27.000 found and then we can set the error to
01:23:30.239 be equal to new error and we can pass
01:23:34.040 this message right in we can also set
01:23:36.159 the status code to 404 so we know
01:23:38.560 exactly what happened resource not found
01:23:42.080 another type of error is a mongus
01:23:44.320 duplicate key that is when we're trying
01:23:46.360 to create something with the same key
01:23:48.560 and this one happens if the error code
01:23:50.760 is 11,000 don't ask me how I know that I
01:23:54.440 en counter this error one too many times
01:23:56.960 so if that is the case we can again form
01:23:59.360 a message equal to something like
01:24:01.920 duplicate field value entered and we can
01:24:05.040 set that error to be equal to new error
01:24:06.920 message and the status code of
01:24:09.880 400 another type of common error is a
01:24:12.560  validation error so when we're
01:24:15.480 trying to create a document and we don't
01:24:17.520 pass all the right props so we can check
01:24:20.280 if error. name is equal to validation
01:24:23.280 error if in this case we'll form the
01:24:26.000 message by mapping over the values of
01:24:29.120 the object because we might have many
01:24:31.480 validation errors and we'll show a
01:24:34.040 message for each one once we do that we
01:24:36.600 can simply set that message to the error
01:24:39.000 and join it based on commas and spaces
01:24:42.560 so for each one of these validation
01:24:44.520 errors We'll add it to the error message
01:24:47.239 and finally we can return the response
01:24:49.639 from this error middleware by saying
01:24:51.440 rest. status is equal to the error
01:24:55.040 status code it can be either 404 or 400
01:25:00.239 or if it doesn't exist we can make it
01:25:02.360 500 which is a general server error and
01:25:05.719 we can return a Json of success is false
01:25:10.880 as well as an error equal to error.
01:25:14.320 message or just a string of server error
01:25:18.040 so in simple words what we're doing here
01:25:20.360 is we're intercepting the error and
01:25:22.719 trying to find a bit more information
01:25:25.119 about it so we much more quickly know
01:25:27.840 what went wrong now we can export that
01:25:30.840 error middleware by saying export
01:25:33.400 default error middleware and we can use
01:25:36.159 it within the app so head over to app.js
01:25:40.360 and then let's add it right here below
01:25:42.000 the routes that'll be
01:25:45.679 app.use and you can call it error
01:25:48.320 middleware and make sure to import it
01:25:50.320 from aor middleware DJs alongside this
01:25:53.480 custom piece of middleware that we
01:25:55.520 created Express also has many built-in
01:25:58.600 middlewares that we can use let's
01:26:00.880 actually add them right here at the top
01:26:03.639 the first one you can see auto
01:26:05.520 recommended to me is app.use
01:26:09.960 express.js this allows your app to
01:26:12.280 handle Json data sent in requests or API
01:26:15.679 calls something that is super common
01:26:18.440 another one is app. use express. URL
01:26:21.920 encoded extended is set to false this
01:26:26.199 helps us to process the form data sent
01:26:28.760 via HTML forms in a simple
01:26:31.679 format and another one you'll often see
01:26:34.159 used is app.use and that is Cookie
01:26:38.480 carser this one has to be imported at
01:26:41.040 the top so make sure to say import
01:26:44.440 cookie parser coming from cookie Das
01:26:48.520 parser this one as the name says reads
01:26:51.520 cookies from incoming requests so your
01:26:53.679 app can store user data if you want to
01:26:55.920 see how all of these works you can just
01:26:57.880 click into them and immediately see the
01:27:00.199 code and since this is the middleware
01:27:02.719 you know what it has to have it has to
01:27:05.239 modify the request right do something
01:27:08.000 with it there's a reason why we had to
01:27:09.840 have it in the first place intercepted
01:27:11.639 it did something with the request
01:27:13.600 modified it and then check this out
01:27:16.360 we're calling the next function letting
01:27:18.440 the request pass through and it's
01:27:20.320 similar with all the other middlewares
01:27:22.080 later on once we start working with our
01:27:25.280 database we'll make one or two of these
01:27:27.480 rookie mistakes and we'll get a very
01:27:29.639 nice error message saying resource not
01:27:31.719 found or duplicate field value entered
01:27:34.560 or maybe a validation error either way
01:27:37.159 creating This Global aor handling
01:27:39.040 middleware will save us hours of
01:27:41.280 debugging later on and it'll make our
01:27:43.880 app that much more scalable great
01:27:47.719 work now that we have our models
01:27:50.560 database setup and error handling
01:27:52.600 middleware we are ready to dive into
01:27:54.880 setting up our off we can do that by
01:27:57.400 opening up a new terminal and installing
01:28:00.080 some packages we can run mpm install
01:28:03.560 Json web token yep we'll Implement a
01:28:06.679 completely custom authentication using
01:28:09.960 jwt's and we can also add bcrypt JS
01:28:14.080 which will allow us to generate
01:28:15.600 randomized strings to Hash our passwords
01:28:18.800 press enter and head over into our env.
01:28:22.400 development. looc let's create a new
01:28:25.440 comment called JWT o and let's create
01:28:29.239 two new environment variables JWT secret
01:28:33.520 this is your string of characters that
01:28:35.800 has to be specific based off of which
01:28:38.159 you'll be able to generate that randomiz
01:28:40.080 string for now I'll simply say secret
01:28:43.000 you can do the same too or enter any
01:28:44.960 kind of random characters and we can
01:28:47.600 also Define when our JWT will expire so
01:28:51.080 we can say JWT expires in and you can
01:28:54.159 set it to any kind of number of days or
01:28:56.360 minutes or hours in my case I'll set it
01:28:59.080 to one day let's not forget to head over
01:29:01.520 to our EnV config and to export those
01:29:04.760 variables so right here we can put this
01:29:07.000 into multiple lines and we can export
01:29:10.280 the JWT
01:29:12.199 secret as well as
01:29:15.080 JWT expires in and with that in mind we
01:29:18.840 can create our first controller so what
01:29:22.400 is a controller well let me create it
01:29:24.840 and show you hopefully it'll all start
01:29:27.119 making sense given the clean code base
01:29:29.440 that we have I'll create a new folder
01:29:32.280 called
01:29:34.360 controllers and within controllers I'll
01:29:36.960 create a new file called o.
01:29:42.320 controller.js and within it we'll create
01:29:44.840 a new function and we can immediately
01:29:47.199 export it so export cost sign up and
01:29:52.080 it'll be equal to an async function
01:29:54.560 where we get the request the response
01:29:57.320 and potentially the next as well and
01:29:59.440 here we can implement the signup logic
01:30:02.480 so this is a dedicated space allowing us
01:30:04.960 to focus explicitly on the logic of what
01:30:08.320 these functions are supposed to be doing
01:30:11.040 we can create another one for sign in
01:30:13.679 which will look like this and the last
01:30:15.760 one for sign out very soon we'll add the
01:30:19.600 logic right here but the question is
01:30:21.840 where are these going to be used I mean
01:30:24.239 remember we already have the O routes
01:30:27.560 and we're going to now merge the two
01:30:29.239 together o routes before handle the
01:30:31.560 logic on their own and sure this is okay
01:30:34.840 if they're all single liners but this
01:30:37.080 logic can very very quickly get very
01:30:40.400 very complicated where we have multiple
01:30:42.760 lines of information and hundreds and
01:30:45.679 hundreds of lines of logic for each one
01:30:48.080 of these functions you can get lost and
01:30:50.480 at the end of the day you'll have no
01:30:52.560 idea what different typ of routes you
01:30:54.920 have and this file is all about routes
01:30:57.560 anyway so with that in mind instead of
01:31:00.360 defining the handlers right here we can
01:31:02.920 Define the controller in a separate file
01:31:05.239 and then import it into here by saying
01:31:07.800 when you make a post request to the
01:31:09.520 author router signup simply do the logic
01:31:13.719 of sign up and that logic will be coming
01:31:17.600 from import sign up from controllers
01:31:22.400 off. controller
01:31:24.480 .js and now we made that connection or
01:31:27.159 the bridge from the O controller to the
01:31:30.119 O routes basically the routes are just
01:31:33.960 the end points that you can hit and the
01:31:36.000 controllers form the logic of what
01:31:38.280 happens once you hit those routes so
01:31:40.880 let's also exchange it for the other two
01:31:44.199 in this case we have sign in as well as
01:31:48.840 sign out we're already exporting them
01:31:51.600 from there so let's just make sure to
01:31:53.440 import them sign in and sign out and
01:31:57.719 with that we have a very clean routes
01:31:59.920 file so at any point in time you know
01:32:02.520 which endpoints you can hit if you want
01:32:05.080 to you can even make a comment of
01:32:07.040 something like path
01:32:09.520 API V1 off sign up why this because in
01:32:14.719 the app we're actually starting it with
01:32:16.960 API V1 o and then in this case it also
01:32:20.520 has a sign up and this is basically a
01:32:23.920 post route you can also write a comment
01:32:27.199 like this for every single one of these
01:32:29.119 routes but again might not be necessary
01:32:32.000 because we're writing your code in a
01:32:33.320 clean way so it's
01:32:35.440 self-explanatory with that in mind let's
01:32:37.520 head into our controller and let's write
01:32:40.080 our first controller of the day the
01:32:42.440 controller for the signup function I'll
01:32:44.800 do it by opening up a new function block
01:32:47.800 and I'll create a new session by saying
01:32:51.000 con session is equal to await
01:32:55.159 dostart session now what does this do
01:32:59.719 well first of all we have to import
01:33:01.800 Mongoose right at the top by saying
01:33:04.199 import from
01:33:07.159  and this session has nothing to do
01:33:10.560 with the user session rather it's a
01:33:13.400 session of a mongoose Transaction what
01:33:17.280 does that mean well here we'll run the
01:33:20.199 session. start transaction and we do
01:33:22.760 this because we want to perform
01:33:24.239 something known as atomic updates also
01:33:27.239 known as atomic operations I found a
01:33:30.080 random photo on Google explaining it but
01:33:32.199 basically database operations have to be
01:33:34.920 Atomic which means that they either have
01:33:36.920 to do All or Nothing insert either works
01:33:40.440 completely or it doesn't update either
01:33:43.119 works completely or it doesn't you never
01:33:45.239 get half of the operation so if you
01:33:47.760 start authenticating the user but
01:33:50.239 somewhere down the line database fails
01:33:53.000 and it doesn't fully add all of its
01:33:54.760 Fields if you still add it to the
01:33:56.679 database unfinished you'll get a lot of
01:33:59.320 Errors later on but if you notice that
01:34:02.119 something went wrong and stop the
01:34:03.719 operation immediately then you won't
01:34:06.040 have any issues and you'll immediately
01:34:07.920 know that something wrong happened
01:34:09.440 that's exactly what we'll do here this
01:34:11.199 is a bit Advanced but bear with me we'll
01:34:13.840 open up a try and catch
01:34:16.679 block and as I said if something went
01:34:20.040 wrong we can immediately await session
01:34:23.920 data board transaction session and
01:34:26.600 session and just call the next with that
01:34:29.040 error this means if at any point
01:34:31.440 something goes wrong don't do anything
01:34:34.119 aboard that
01:34:35.560 transaction but here we can actually try
01:34:38.560 to insert a new user and then at the end
01:34:42.040 we will commit that session which means
01:34:44.800 that we are ready to commit to all of
01:34:47.520 the actions we have done above hopefully
01:34:49.880 it makes sense I'll try to explain it as
01:34:51.800 we go basically the goal of this
01:34:54.239 function is to create a new user so
01:34:57.199 let's get the data needed to know which
01:34:59.840 user we want to create in backend apis
01:35:02.600 you typically get all of that
01:35:04.000 information through a request body so
01:35:08.199 what is a request body let's explain it
01:35:10.920 what is a request body a request body is
01:35:15.320 an object containing the data coming
01:35:17.560 from the client specifically when you
01:35:20.440 have a post request why am I me
01:35:23.679 mentioning the post well because if you
01:35:25.800 check the routes right here you'll
01:35:28.000 notice that the signup functionality is
01:35:30.639 indeed a post route and opposed to just
01:35:34.000 a get request where you simply make a
01:35:35.800 call and that's it on the post request
01:35:38.920 you're also allow to pass some data in
01:35:42.159 this case that data will of course be
01:35:44.960 something like the username or email or
01:35:47.760 password so we can destructure the past
01:35:50.800 values from the front end right here con
01:35:53.840 name email and password is equal to
01:35:56.719 request. body after that we can check if
01:35:59.920 a user already
01:36:02.119 exists we can do that by saying const
01:36:05.320 existing user and here we'll make our
01:36:08.920 first database call by using and
01:36:12.800 saying
01:36:13.760 await user keep in mind this user is
01:36:17.360 referring to the user model that we
01:36:19.400 created not that long ago and we'll say
01:36:22.560 user. find one where the email is the
01:36:27.320 same as the one that the user is trying
01:36:29.280 to create a new user account with then
01:36:31.880 if an existing user already exists in
01:36:36.320 that case we can create a new error by
01:36:39.840 making it equal to new error user
01:36:42.760 already exists and we can set the status
01:36:45.440 code to 409 and throw that error this
01:36:49.320 typically means already exists if it
01:36:51.840 doesn't exist we can have hash the
01:36:54.320 password for the new user hashing a
01:36:57.480 password means securing it because you
01:37:00.119 never want to store passwords in plain
01:37:02.960 text so how does it work well first you
01:37:06.520 need to get access to something known as
01:37:08.560 salt which is like a complexity you want
01:37:10.880 to use for randomizing your hashed
01:37:13.239 password so let's say salt is equal to
01:37:16.560 await
01:37:18.480 bcrypt do gen salt so this is a method
01:37:22.719 and typically the default number is 10
01:37:25.920 make sure to import bcrypt coming from
01:37:30.400 bcrypt right here that's bcrypt JS once
01:37:34.080 we have the Sal we can get the hashed
01:37:36.199 password by saying const hashed password
01:37:39.679 is equal to await bcrypt do you pass the
01:37:45.280 plain text password from the user and
01:37:47.840 the salt you generated right
01:37:50.239 above once you have it we are ready to
01:37:52.719 create a new user Us by saying con new
01:37:55.520 user is equal to await user. create and
01:38:00.239 now we can pass an array of how many new
01:38:02.520 users you want to create alongside with
01:38:04.560 their info for now we only want to
01:38:07.199 create a single user so I'll pass their
01:38:10.000 name equal to name email equal to email
01:38:14.000 and password equal to hashed password
01:38:17.719 now something could go wrong when
01:38:19.199 creating this user so that's why we want
01:38:21.840 to also attach a session to it which
01:38:25.119 means that if something goes wrong and
01:38:27.520 if we later on aboard that transaction
01:38:30.760 then the user will not be created but if
01:38:33.599 you reach the end of the tri block means
01:38:35.960 we're good and we'll actually commit the
01:38:38.119 transaction which will create the user
01:38:40.400 finally let's generate a token for the
01:38:42.560 user so they can sign in cons token is
01:38:45.599 equal to
01:38:46.639 JWT we have to import JWT at the top
01:38:50.679 coming from Json web token
01:38:54.560 and we can say
01:38:56.400 JWT do sign which will take in an object
01:39:00.280 of user
01:39:01.480 ID is equal to new user
01:39:06.040 0 doore ID we're calling zero right here
01:39:10.040 because when you pass an array of
01:39:11.920 documents you create it will return the
01:39:14.199 array of new users so maybe it's going
01:39:16.360 to be better to call this new users and
01:39:18.719 then we get the first and only one which
01:39:20.719 we create and get their ID and as the
01:39:23.679 second parameter you have to pass the
01:39:25.520 JWT
01:39:27.159 secret and as the third parameter you
01:39:29.960 can pass an object with additional
01:39:31.719 options such as expires
01:39:34.440 in and you could manually type it but we
01:39:37.320 already created a JWT expires in
01:39:41.000 environment variable hopefully this
01:39:42.880 makes sense we are attaching a Json web
01:39:45.760 token to the user with the following ID
01:39:49.159 once you do that we are ready to commit
01:39:51.000 the transaction end the session and
01:39:54.080 finally return the rest.
01:39:57.239 status of 2011 which means created do
01:40:01.760 Json and we can return the success is
01:40:05.520 equal to True message is equal to user
01:40:09.360 created
01:40:11.119 successfully and we can pass the data
01:40:13.679 such as the token as well as user which
01:40:17.040 is equal to new users zero this is the
01:40:20.920 function to create a new user
01:40:24.239 so let's go ahead and collapse it and
01:40:27.280 we're already exporting it and using it
01:40:30.159 right here under our off routes so as
01:40:33.199 soon as somebody hits this endpoint this
01:40:35.880 function will be executed so let's test
01:40:38.480 it together you could either watch me do
01:40:40.520 it or you could download one of these
01:40:42.360 HTTP clients and test it on your own so
01:40:45.360 we have to head over to API V1 o and
01:40:49.520 then make a post request but we also
01:40:52.280 have to pass a body and this body will
01:40:55.239 be in form of adjacent so I'll create a
01:40:57.920 new object and remember now we have to
01:41:00.800 specify these three things which our
01:41:03.320 code will then accept the name email and
01:41:06.599 password so for the name I'll do
01:41:09.000 something like Adrian JS Mastery and
01:41:12.800 we're working within Json so make sure
01:41:14.800 to wrap everything in double quoted
01:41:18.639 strings the email will be something like
01:41:23.400 contact JS mastery. proo and finally the
01:41:28.000 password can be something like 123 1 23
01:41:33.239 perfect the body seems to be good and we
01:41:35.840 are ready to make a request this time
01:41:38.599 instead of getting simply the title of
01:41:40.560 create
01:41:41.880 subscription we should get back whatever
01:41:44.280 this function is
01:41:46.000 returning a 2011 with a success true a
01:41:49.880 message and the data of the newly
01:41:52.159 created user
01:41:54.280 so let's give it a spin I'll click Send
01:41:57.719 and we get a 404 oh that's because I
01:42:00.280 just hit off but in this case if you
01:42:03.000 take a look at our path it actually has
01:42:05.239 a forward slash sign up as well so we
01:42:08.000 can differentiate it from sign in and
01:42:09.960 sign out so if I append sign up to it
01:42:12.960 and click send you can see false user is
01:42:16.000 not defined okay this is good in a way
01:42:18.840 because at least we got some meaningful
01:42:20.560 information right here see success is is
01:42:23.320 false and then we get the error
01:42:25.400 message if that sounds familiar it could
01:42:28.280 be coming from aor middleware where we
01:42:30.400 actually return a success of false and
01:42:33.080 then a meaningful error message if it
01:42:35.320 comes to it and in this case the error
01:42:37.360 messages user is not found so this is
01:42:40.560 helpful to us if we now search for user
01:42:44.040 you can see that I'm mentioning it a
01:42:45.719 couple of times because this is all
01:42:47.599 about users but I think the one that we
01:42:50.440 should be concerned with is this one
01:42:53.400 right here where we're trying to create
01:42:55.639 a new user you don't create it with a
01:42:58.360 lowercase user in mind you create it
01:43:00.960 based off of the user model which starts
01:43:04.440 with a capital u it's this model we
01:43:07.159 created based off of all of these
01:43:09.159 properties so now that I fixed this typo
01:43:11.840 I'm actually glad it happened because we
01:43:13.520 got a chance to explore how to handle
01:43:15.520 errors I'm ready to send another request
01:43:18.719 so I'll click Send and this time we got
01:43:21.400 yet another error saying JWT secret is
01:43:24.400 not defined this time it's referring to
01:43:26.719 this one right here and if you can see I
01:43:29.560 forgot to import it from our envs so
01:43:32.480 let's get it right
01:43:34.000 here save the file and send it once
01:43:38.440 again this time we get a 2011
01:43:42.159 created you can see all the information
01:43:44.480 about the request that is being made
01:43:46.639 success true message user created
01:43:48.920 successfully and the data with the
01:43:51.280 user's token as well as their name email
01:43:54.800 and a hashed password would you look at
01:43:57.239 that we also get a user
01:43:59.679 ID and created at and updated at Fields
01:44:03.280 now what I would recommend is saving
01:44:05.320 this user token as we might need it for
01:44:07.520 future
01:44:08.599 requests so maybe add it I don't know
01:44:11.760 let's add it to our EnV development just
01:44:14.199 so we know and I'll add a comment of
01:44:18.280 token and paste it right here and we can
01:44:22.080 also add another one for the underscore
01:44:25.360 ID so if we need to get the ID of our
01:44:27.840 user very quickly we can always grab it
01:44:30.679 from this file great and since we got a
01:44:33.880 2011 that must mean that the user was
01:44:36.119 indeed created in the database so if we
01:44:38.480 head over to our clusters and click on
01:44:40.840 cluster
01:44:41.920 zero head over to collections you should
01:44:45.040 be able to see users and you can see a
01:44:48.560 new user created in the database that
01:44:51.040 means that our first post a API call
01:44:53.840 succeeded and it talked to the database
01:44:56.520 and created a new user now if you have
01:44:58.719 any issues with mongodb you might need
01:45:01.239 to head over to network access and add
01:45:03.880 an IP address and click allow access
01:45:06.639 from anywhere sometimes it stops some IP
01:45:09.480 addresses so you cannot make changes so
01:45:12.119 if you do this it'll just work for all
01:45:14.679 IPS great now let's head back to the
01:45:17.760 code to O controllers and let's create
01:45:20.960 the signin function which would will
01:45:23.119 allow us to sign our user in I'll do it
01:45:26.599 right here and first I will open up a
01:45:30.520 try and catch
01:45:32.520 Block in the catch I'll simply get the
01:45:35.040 error and forward it over to our error
01:45:38.520 handling middleware but in the try I'll
01:45:41.040 try to destructure this time just the
01:45:43.960 email and the password from the body no
01:45:46.440 need to get the name because we're
01:45:47.880 already signing in to our
01:45:49.800 account then we'll check if a user
01:45:52.159 exists by saying const user is equal to
01:45:55.639 await user. find one with a specific
01:46:00.960 email and by the way if you're wondering
01:46:03.320 how this filter thing popped up right
01:46:05.199 here that is something that webstorm IDE
01:46:08.080 adds it automatically recognizes what
01:46:11.000 this find one method wants as the first
01:46:13.520 parameter and it tells us what that is
01:46:16.400 next if a user doesn't exist we can
01:46:19.119 throw a new error something like user
01:46:21.480 not found 404 for but if it does exist
01:46:24.880 we can try to validate their password by
01:46:27.400 saying const is password
01:46:30.480 valid and we'll do it by using await
01:46:34.080 bcrypt coming from bcrypt
01:46:36.639 js. compare where we want to compare the
01:46:40.280 new password they entered with the user
01:46:43.199 password stored in the database of
01:46:45.400 course bcrypt will actually hash this
01:46:47.679 new password that you're typing and
01:46:49.520 compare it with the hashed password in
01:46:51.159 the database let's just it properly that
01:46:53.920 is compare and make sure to import
01:46:56.000 bcrypt from the top next if it's not
01:46:58.760 valid so if password is not valid we can
01:47:01.360 throw another error saying new error
01:47:03.840 invalid password with a 41 which means
01:47:07.520 unauthorized but if it is valid we can
01:47:10.199 generate a new token which will be
01:47:13.040 similar to what we had before JWT doign
01:47:16.880 user ID is equal to user doore ID this
01:47:20.840 time we don't have to destructure the
01:47:23.400 first element from it because we're not
01:47:25.560 adding that session transaction because
01:47:27.480 this is just a sign in not a sign up so
01:47:31.320 we're not creating anything we pass over
01:47:33.360 the jwd secret and the expires in
01:47:36.760 functionality once we do that we are
01:47:38.800 ready to return a rest that status of
01:47:41.880 200 which means successful and as
01:47:44.440 adjacent object we'll pass success true
01:47:47.000 user signed in successfully and we will
01:47:50.000 return the data of the token and the
01:47:53.599 user great so now we have the
01:47:56.119 functionality to sign our users in as
01:47:58.599 well let's make sure that we have
01:48:00.320 actually pass it as a controller to the
01:48:03.040 signin route and we can actually test it
01:48:05.560 out if I now go over to sign
01:48:08.840 in and I remove my name because we don't
01:48:12.159 need it but I do need the correct email
01:48:14.880 and password we should be able to sign
01:48:17.679 in successfully so I'll click Send and
01:48:21.000 you can see user signed in successfully
01:48:23.360 and we get a new token if needed
01:48:26.520 beautiful if you try to sign in with an
01:48:29.199 invalid password like something like 1 2
01:48:32.040 3 4 5 6 you can see invalid password or
01:48:36.040 if you try to sign in with an email that
01:48:38.199 doesn't exist maybe you make a typo
01:48:40.320 you'll see user not found beautiful
01:48:43.880 complete error handling so if you now
01:48:45.719 had a beautiful front end application
01:48:48.000 you would be able to nicely show these
01:48:50.080 errors on the front end allowing your
01:48:52.320 users to see what they did wrong we're
01:48:54.599 using this HTTP client to mock what the
01:48:57.679 user would be seeing on the front end
01:48:59.239 but basically this would be a form and
01:49:01.679 what does that form do well it basically
01:49:04.080 calls our API that's how it goes you
01:49:07.320 make a nice form on the front end and
01:49:09.400 you make a call to API V1 o sign up and
01:49:15.159 you pass all the post request details
01:49:17.920 like the post body such as the name
01:49:20.040 email and password and it creates
01:49:22.719 creates a new user make sense hopefully
01:49:27.400 it does and with that we're ready to
01:49:29.320 move to the second part of creating our
01:49:31.639 users and that is authorization once
01:49:34.599 we've created our users we need to be
01:49:36.560 able to authorize them meaning make a
01:49:39.280 get call to the database to figure out
01:49:41.639 which users are in
01:49:44.159 there to authorize our users let's
01:49:47.199 create a new file right here within the
01:49:49.520 controllers folder and let's call it
01:49:52.040 user
01:49:54.440 controller.js within here we can import
01:49:57.119 the user model coming Fromm models user.
01:50:01.440 model. JS and we can Define two
01:50:04.400 functions the first one will fetch all
01:50:07.159 users so we can say export const get
01:50:10.360 users is equal to an asynchronous
01:50:13.199 function which accepts the request and
01:50:15.000 the response as the prams and we can
01:50:17.560 open up a try and catch Block in the
01:50:20.599 catch we get the error and we can simply
01:50:23.119 forward it over to our error handling by
01:50:25.920 saying next error and that next is
01:50:28.280 coming as the third parameter right here
01:50:30.440 into this function but when it comes to
01:50:32.800 what we'll actually try to do in this
01:50:34.800 function we can try to fetch the users
01:50:37.440 by saying const users is equal to await
01:50:41.599 user. find and we'll simply find all the
01:50:44.760 users like this next we can say res.
01:50:48.400 status.
01:50:50.079 200 and in the Json we can simply return
01:50:53.440 a success is equal to true as well as
01:50:56.880 data is equal to users and this is it
01:50:59.679 this is a function that fetches all the
01:51:01.360 users from the database we can duplicate
01:51:03.679 it below and rename it to get user which
01:51:07.639 will get a singular user in this case
01:51:10.560 we'll say user is equal to user. find by
01:51:14.280 ID and to it we can pass the rec. prams
01:51:18.520 doid and then also call the do select
01:51:22.040 where we're going to select all the
01:51:23.679 fields minus the password we just want
01:51:26.119 to get the user info but we don't care
01:51:27.960 about the password we only care about
01:51:29.800 that when logging in finally if there is
01:51:32.239 no user that we're trying to fetch we
01:51:34.960 can create a new error by saying const
01:51:38.280 error is equal to new error and we can
01:51:41.280 say user not found we can also set the
01:51:44.000 error. status code to 404 and throw it
01:51:47.800 that way we'll be able to catch it right
01:51:50.119 within our error handling middleware
01:51:52.840 else we'll simply say res. status 200
01:51:55.639 Json success true and data is equal to
01:51:59.000 user singular user now great so now
01:52:02.239 let's put those two to use by heading
01:52:04.560 over into our routes specifically user
01:52:08.639 routes we have a route that fetches all
01:52:11.159 the users so I can simply do it right
01:52:13.639 here I'll call the get users there we go
01:52:17.920 and then right below it we have another
01:52:19.719 one which fetches the users based on its
01:52:21.880 ID so here we can call the get user and
01:52:25.920 make sure to import both of these coming
01:52:27.920 from controllers user. controller.js and
01:52:31.119 this is a pretty cool thing see how we
01:52:32.920 have this Dynamic parameter of ID now
01:52:35.679 how are we fetching it in the get user
01:52:38.199 well it's getting to us through Rec
01:52:40.480 params ID you know how through the post
01:52:43.440 requests we can pass a request body but
01:52:46.719 through get requests we can also pass
01:52:48.639 the data through the request parameters
01:52:51.360 so in this case since it's called the ID
01:52:54.320 we can extract that ID value right from
01:52:56.679 Rec prams ID now let's go ahead and test
01:52:59.320 it out I'll open up our HTTP client and
01:53:02.280 we want to Target the API V1 and then
01:53:05.800 users endpoint and this time we're
01:53:08.520 making a get request if you do this and
01:53:11.159 click Send you'll be able to see create
01:53:13.639 new user oh looks like it didn't switch
01:53:15.520 the request so if you do it one more
01:53:18.239 time and click Send now you can see the
01:53:20.599 only user that we created with our name
01:53:23.679 email and password now what we could do
01:53:26.320 is maybe prevent regular users from
01:53:28.920 making this call because it could expose
01:53:31.040 all the users in the database I'll show
01:53:33.079 you how to do that very soon but for now
01:53:35.239 let's grab this user's ID and let's make
01:53:38.320 a request to the same URL but append
01:53:41.520 that ID right at the end and make a
01:53:44.199 request and now you can see the success
01:53:46.520 true and data only for that user this
01:53:49.079 time no password but as I said we need
01:53:51.320 to be able to protect our routes for
01:53:53.840 example this user Details page should be
01:53:56.480 private and to do that we can also use
01:53:58.800 middleware this time we can think of it
01:54:01.480 as authentication middleware so right
01:54:04.159 within middlewares create a new file
01:54:06.800 called o. middleware DJs and create a
01:54:10.840 new
01:54:11.920 function const authorize which will be
01:54:15.000 equal to an asynchronous function that
01:54:17.199 accepts the request the response and the
01:54:19.360 next and opens up a try and catch Block
01:54:23.040 in the catch we can run res that status
01:54:25.520 of 401 which means
01:54:28.639 unauthorized and return a Json
01:54:31.719 output with a message of unauthorized as
01:54:35.560 well as pass some additional error
01:54:37.000 information in form of the error message
01:54:40.320 but in the try we can try to get access
01:54:42.560 to the user's token by saying let
01:54:45.760 token and then having an if statement
01:54:48.360 where we check for rec. headers do
01:54:51.480 authorization and if rec. headers do
01:54:56.760 authorization dot starts with Bearer
01:55:00.960 typically when you pass a token through
01:55:02.719 the rec headers it starts with the word
01:55:05.159 Bearer it's just a protocol so if that
01:55:07.440 is the case then we know that the token
01:55:09.400 will be there and we can say token is
01:55:11.599 equal to rec. headers do authorization
01:55:14.400 dosit and we'll split the word Bearer
01:55:17.159 and return just the second part of that
01:55:19.440 string which will be the actual token we
01:55:21.760 can go out outside of that if and check
01:55:24.280 if there is no token in that case we can
01:55:27.639 return a rest. status of
01:55:30.520 401 and a message of unauthorized else
01:55:34.239 if we do get the token we have to verify
01:55:36.239 it by saying const decoded is equal to
01:55:40.400 JWT do verify and you have to pass the
01:55:43.639 token and our JWT secret coming from our
01:55:47.320 EnV config so make sure to import it
01:55:49.880 from here and also make sure to import
01:55:53.079 the JWT from Json web token once we
01:55:56.400 decod it we can check if the user still
01:55:58.800 exists by fetching it from the
01:56:01.000 database const user is equal to await
01:56:05.400 user. find by ID and we'll use the
01:56:07.840 decoded user do user ID if it doesn't
01:56:12.119 exist we'll simply return once again a
01:56:14.760 401 of unauthorized and if it does exist
01:56:18.440 we'll attach the user to the request
01:56:21.760 that is being made and then forward it
01:56:23.639 over to the second part of the request
01:56:25.760 so basically what this middleware is
01:56:27.400 doing is it's trying to find the user
01:56:30.400 based off of the token of the user that
01:56:32.599 is trying to make the request it looks
01:56:35.239 if it's there it decodes it verifies
01:56:37.560 that that is the user that is currently
01:56:39.159 logged in and then it attaches it to the
01:56:41.560 request so later on when we're doing
01:56:43.840 something we can know who exactly is
01:56:46.920 making that request because now we have
01:56:48.760 this additional information so in simple
01:56:50.880 words let's say that some somebody is
01:56:52.599 trying to make a
01:56:54.000 request making a request to example get
01:56:58.079 user details then we call this
01:57:00.880 authorized
01:57:02.320 middleware we verify who is trying to do
01:57:05.960 it and if they have permissions or if
01:57:09.360 valid then we go over to the next step
01:57:11.760 and give access to the user details so
01:57:14.280 how can we actually put this authorized
01:57:15.880 middleware to use well let's head over
01:57:19.119 into our user. route. Js
01:57:23.719 and remember what I told you will
01:57:25.560 authorize the user Details page so only
01:57:29.119 the user that is currently logged in can
01:57:31.119 see its own details no no one else and
01:57:34.800 the only thing you have to do to make it
01:57:36.360 work is import that
01:57:40.239 authorize
01:57:41.880 from middlewares
01:57:44.560 sl. middleware
01:57:47.040 DJs oh and I think I forgot to export it
01:57:50.000 so this was supposed to be const
01:57:52.840 authorize and we can run export default
01:57:55.880 authorize and the only thing you have to
01:57:58.159 do is add it right here after the path
01:58:01.239 but before the next function this is why
01:58:04.040 it's called middleware because it is in
01:58:05.800 the middle from when you start making a
01:58:07.679 request to when you end it and in case
01:58:10.440 you want to add a second middleware
01:58:12.159 maybe like air handling middleware you
01:58:14.440 can add it right here as well and you
01:58:16.440 can keep chaining as many middle Wares
01:58:18.679 as you want as long as they all end in
01:58:21.679 the next because they'll forward it over
01:58:23.760 to the next function but now this get
01:58:26.639 user will actually have access to the
01:58:29.960 user object because we authorized it
01:58:32.079 beforehand so let's put it to the test
01:58:34.599 if I retry the same request that we made
01:58:36.760 not that long ago where we got
01:58:38.320 successful user
01:58:39.639 details now you'll see 401 unauthorized
01:58:43.560 okay this is good we don't have a token
01:58:45.840 and it's not working exactly what we
01:58:48.040 wanted but now to pass this
01:58:49.719 authorization we'll have to sign in to
01:58:52.119 get a token to get it you can just go to
01:58:54.360 API V1 o and then SL signin and enter
01:58:59.719 your email and password that you use at
01:59:02.000 the start if you forgot it you can just
01:59:04.239 create a new account by going to sign up
01:59:06.800 and passing over your email name and
01:59:09.119 password so now I'll click sign in and
01:59:12.040 of course this is not a get request it's
01:59:14.199 going to be a post request so if I click
01:59:17.480 it there we go user signed in
01:59:19.800 successfully and we got our token
01:59:22.719 before copying the token first copy the
01:59:25.119 user ID and add it right here to the
01:59:27.480 request where we're going to go for API
01:59:30.560 V1 users and then user ID and also copy
01:59:35.119 the bearer token and make a get request
01:59:38.079 to this URL but now within off you can
01:59:41.079 select a bearer token and paste that
01:59:43.400 token right here this should allow you
01:59:45.599 to fetch the details of this user so
01:59:48.159 click Send and we got unauthorized but I
01:59:51.280 think I know why that is it's because we
01:59:53.320 haven't defined our user so if you head
01:59:55.480 over to user middleware I think we
01:59:57.760 forgot to import this user right here
02:00:00.760 it's supposed to be coming from
02:00:03.000 Doods user. modelj so now that we fixed
02:00:06.639 that issue thankfully we have proper
02:00:08.520 error handling here let's try to remake
02:00:10.599 that request this time with a token and
02:00:14.000 there we go we get back the information
02:00:16.560 but if we remove this token from there
02:00:19.119 you can see that we don't have the
02:00:20.760 permission to access it so hopefully
02:00:23.040 that makes sense that is how we
02:00:25.040 authorize or protect certain routes by
02:00:27.679 allowing only specific users to see them
02:00:30.520 you can always extend this to add
02:00:32.360 stricter rules for example for only
02:00:34.800 admins to be able to make requests to
02:00:37.000 get all users the only thing you have to
02:00:38.960 do is add a check if that user is an
02:00:41.360 admin or a regular user you can do that
02:00:43.840 using the same authorized middleware or
02:00:45.960 you can create another piece of
02:00:46.920 middleware only for that and talking
02:00:48.880 about making stricter rules for your
02:00:50.599 apps typically there's always one or two
02:00:53.440 nasty users that will try to spam your
02:00:55.760 apis or websites by making too many
02:00:58.119 requests one after another that's not
02:01:01.079 good because it's slowing down your
02:01:02.239 server and increasing the costs and
02:01:04.480 right now they can totally do that I
02:01:06.639 mean check me out I'm just making tons
02:01:08.599 of requests right now and imagine if
02:01:10.560 they coded a bot to just Spam thousands
02:01:12.920 of them so in the next lesson I'll teach
02:01:15.040 you how we can restrict the number of
02:01:16.880 requests a user can make in a certain
02:01:19.320 period of time almost every production
02:01:21.760 app app does this so let me teach you
02:01:24.719 how to do
02:01:26.480 it just for a second imagine you run a
02:01:29.880 small coffee shop and then at one moment
02:01:33.119 hundreds of customers come in and order
02:01:35.920 500 cups of coffee each that will
02:01:38.639 significantly slow down the service
02:01:40.400 right well that's exactly what happens
02:01:42.480 to websites and apis and apps without R
02:01:45.920 limiting or bot protection just see how
02:01:48.800 congested it can be transaction in
02:01:50.800 progress and all the users will be stuck
02:01:53.440 waiting for their data for days right
02:01:55.760 limiting is like a rule that says hey
02:01:58.320 you can make a certain number of request
02:02:00.079 in a given time and it prevents people
02:02:02.560 or most commonly Bots from overwhelming
02:02:05.159 your servers with two many requests at
02:02:07.599 once keeping your app fast and available
02:02:10.320 for everyone and of course even more
02:02:12.079 important to say is that not all website
02:02:14.560 visitors are human there are many Bots
02:02:16.760 trying to scrape data guess passwords or
02:02:19.880 just Spam your service bot prot
02:02:21.880 protection helps you detect and block
02:02:23.960 this kind of bad traffic so your
02:02:25.719 platform stays secure and functional and
02:02:28.280 that's exactly what we'll do with our
02:02:29.880 API to make it safe and secure if you
02:02:32.440 haven't already done that click the
02:02:34.000 arcjet link down in the description to
02:02:36.119 be able to follow along and see exactly
02:02:38.280 what I'm seeing and then sign up for
02:02:39.960 free once you do that enter your API
02:02:42.400 name I'll say subscription
02:02:45.320 tracker and create and you'll be able to
02:02:48.040 choose between many options of the
02:02:49.880 services you can integrate it with from
02:02:51.920 bun to bun and hono Deno NES nextjs no
02:02:55.079 JS in this case no JS and express is the
02:02:57.920 perfect fit for us so let's just copy
02:03:00.360 this arcjet key and click continue with
02:03:02.480 no and express before we follow the docs
02:03:04.840 let's just head into our app into env.
02:03:08.440 development. looc and let's add arcjet
02:03:11.599 environment variables that'll be arcjet
02:03:15.000 key is equal to this key that you just
02:03:17.800 copied as well as
02:03:19.880 arcjet corv which is set to development
02:03:23.639 so we know we're currently in the
02:03:24.880 development environment we'll also have
02:03:26.719 to head over to our EnV config and add
02:03:29.840 the arcjet EnV right here as well as
02:03:33.400 arcjet key so we're properly exporting
02:03:36.239 them perfect and it seems like webstorm
02:03:39.000 doesn't know about the word arcjet so
02:03:41.560 I'll simply add it to my dictionary
02:03:43.639 because I'll be using it much more
02:03:44.960 frequently from now on with that in mind
02:03:47.000 let's follow the steps outlined right
02:03:48.599 here we have already installed Express
02:03:51.159 now we have to install arcjet so let's
02:03:53.599 just copy this command and in our second
02:03:55.760 terminal we can just run mpmi arcjet SL
02:04:00.400 node while that is installing let's set
02:04:02.639 up our key perfect this is exactly what
02:04:05.400 we have done and now we are ready to add
02:04:08.000 some rules what you could do is add
02:04:10.360 those rules directly within the appjs
02:04:12.760 file which is totally okay but in this
02:04:15.320 case we'll actually do it in a separate
02:04:17.559 file to keep our code-based ID so back
02:04:19.960 in the code create a new new middleware
02:04:22.400 file which I'll call arcjet middleware
02:04:26.599 DJs and before we set up the arcjet
02:04:29.000 middleware we first have to configure an
02:04:31.040 active instance of arcjet which I'll do
02:04:33.559 in the config file so let's go ahead and
02:04:35.719 create a new file called arcjet DJs
02:04:39.079 within the config and we can get started
02:04:40.920 by copying this const AJ from arcjet and
02:04:44.400 then pasting it right here this will
02:04:46.079 give us a head start on the
02:04:47.119 configuration we'll have to import a
02:04:48.800 couple of things such as import rjet
02:04:52.480 as well as in curly braces Shield detect
02:04:56.679 bot as well as token bucket all of this
02:05:00.639 is coming from
02:05:02.159 arcjet so first things first we have to
02:05:05.000 get our site key from arcjet and set it
02:05:07.760 as an environment variable coming from
02:05:09.800 process. env. arcjet or in this case we
02:05:13.239 can just say arcjet key coming from EnV
02:05:16.599 JS like this we can leave the
02:05:18.760 characteristics as they are track
02:05:20.840 requests by IP address then we have a
02:05:23.599 couple of rules the first rule is The
02:05:25.760 Shield which protects our app against
02:05:28.079 common attacks like SQL injections this
02:05:31.520 is super convenient because it allows
02:05:33.800 you to focus on implementing your api's
02:05:36.280 business logic while arcjet handles the
02:05:38.920 protection side and we also have a bot
02:05:41.440 protection where you can also specify
02:05:43.920 different rules of how you want to
02:05:45.400 protect them in this case we're setting
02:05:47.400 the mode to live and under allow we have
02:05:50.440 category search and engine which allows
02:05:52.880 search engines to access our site if you
02:05:54.920 want to turn it on for monitoring or
02:05:57.079 preview you can do that as well I'll
02:05:59.000 keep it as it is and right below we have
02:06:01.679 something known as a token bucket and
02:06:04.239 this is used for rate limiting if you
02:06:06.119 head over to the docs for the rate limit
02:06:08.159 configuration you can see that each
02:06:09.920 arcjet rate limit rule has its own
02:06:12.199 configuration depending on the algorithm
02:06:14.480 used they start from the type and then
02:06:16.679 the algorithm there are different
02:06:18.159 options that we can pass into it and
02:06:20.280 characteristics but if you scroll a bit
02:06:22.320 down you'll be able to see a detailed
02:06:24.159 explanation for each one of the
02:06:25.760 parameters that we pass into the
02:06:27.280 function so if I put this to the side
02:06:29.400 you can see that an interval can be a
02:06:31.480 number or an integer it is supported for
02:06:33.840 these types of algorithms in this case
02:06:35.639 we're using a token bucket algorithm and
02:06:38.079 for the token bucket if you set the
02:06:39.719 interval to 60 and the refill rate to 10
02:06:43.040 the bucket will refill 10 tokens every
02:06:45.159 60 seconds here you can learn more about
02:06:47.440 the refill rate and the capacity arcjet
02:06:50.360 is using actual rate limiting algorithms
02:06:53.159 not just a set number of calls that each
02:06:55.800 IP address can make the default option
02:06:58.040 right here is that it refills five
02:06:59.840 tokens per interval refills every 10
02:07:02.159 seconds and the bucket capacity is 10
02:07:04.599 tokens we'll soon see if we can break
02:07:06.920 that by trying to make too many requests
02:07:09.400 great this is all it takes to configure
02:07:11.800 arcjet so let's head over into our
02:07:14.040 middleware to use it we can import AJ
02:07:17.800 coming
02:07:18.760 fromc config SLR Jet .js and we can
02:07:23.440 create a new function called arcjet
02:07:26.159 middleware it has the request the
02:07:28.280 response and the next we can open up a
02:07:30.400 tri block as well as a catch block and
02:07:33.880 if there's an error we'll simply Cog
02:07:36.000 that error but I will
02:07:38.079 prepend arcjet middleware
02:07:41.599 error and then we can display the error
02:07:44.000 message right after it just so we know
02:07:46.800 where the error is coming from and then
02:07:48.960 we will call the next and pass over that
02:07:51.239 error
02:07:52.000 finally in the try we can start with
02:07:54.559 this const decision is equal to await
02:08:00.599 aj. protect and the only thing we'll
02:08:03.840 pass in is the request so we're saying
02:08:06.559 protect this request and tell me your
02:08:09.719 decision should it be denied or should
02:08:12.440 we let it through if decision dot is
02:08:17.000 denied which is a function so make sure
02:08:19.159 to call it right here will open up a
02:08:21.679 block and then we'll figure out what is
02:08:23.840 the reason for the
02:08:25.800 denial if decision do
02:08:30.559 reason do is rate limit if that is the
02:08:34.199 case we'll return a status of 429 with a
02:08:38.960 Json message of error rate limit
02:08:41.960 exceeded or too many requests we can
02:08:45.000 actually put this in one line right here
02:08:47.079 we can have another if statement right
02:08:48.920 within it and we'll say if decision
02:08:51.920 reason dot is bot okay so we're
02:08:55.760 implementing bot protection here in that
02:08:58.400 case we'll return a restat status of 403
02:09:02.360 and say bot detected if it's neither one
02:09:05.239 of these but if it's just denied we'll
02:09:08.000 return a four or three and say access
02:09:10.079 denied now outside of the if that means
02:09:13.119 that we're not denying the request to
02:09:14.920 pass through we'll just simply say next
02:09:17.159 go to the next step whether that's to
02:09:19.159 create a subscription create a user or
02:09:21.480 whatever you wanted to do without
02:09:22.960 request maybe order a coffee so with
02:09:25.679 this we're implementing that additional
02:09:27.639 layer of protection now let's export
02:09:30.559 default that arcjet middleware and let's
02:09:34.119 put it to use right within our
02:09:37.320 app.js here we have all sorts of
02:09:39.599 different middlewares and we can also
02:09:41.840 add the app.use arcjet middleware and
02:09:46.119 make sure to import it from middlewares
02:09:48.199 arcjet middleware DJs so what do you say
02:09:51.559 that we put it to the test let's just go
02:09:53.719 back to arjit middleware one more time
02:09:55.599 and make sure that we have properly
02:09:56.960 implemented it oh it looks like we're
02:09:59.400 using a weight here so I need to add
02:10:01.520 async right at the top and let's check
02:10:04.320 out our arjit file and make sure to
02:10:06.840 export default the AJ configuration
02:10:09.719 instance so we can use it right here to
02:10:12.159 protect us and if you head over to the
02:10:14.119 arjit config just to make sure we're
02:10:16.040 doing good this is supposed to be coming
02:10:18.199 from at arcjet SL node if we fix that
02:10:22.320 you'll see that our subscription tracker
02:10:23.920 is now running on Local Host 5500 now
02:10:27.360 just before we test it I want to explain
02:10:29.480 how this stoken bucket algorithm Works
02:10:31.480 in a bit more detail see this algorithm
02:10:34.559 is based on a bucket filled with a
02:10:36.719 specific number of tokens each request
02:10:39.480 withdraws a token from the bucket and
02:10:41.800 the bucket is refilled at a fixed rate
02:10:44.760 once the bucket is empty the client is
02:10:46.760 blocked until the bucket refills this is
02:10:49.159 useful when you want to allow clients to
02:10:51.040 make a burst of requests and then still
02:10:53.159 be able to make requests at a slower
02:10:54.960 rate for this to work along longside
02:10:57.000 providing the refill rate the interval
02:10:58.800 and capacity you also have to choose how
02:11:02.119 many tokens will you deduct once you
02:11:04.599 determine each request and this is
02:11:06.960 happening when we call the AJ protect so
02:11:09.920 if you head over into aret middleware
02:11:12.480 you'll have to provide a second
02:11:13.920 parameter to aj. protect of requested
02:11:18.040 set to one which means that you'll take
02:11:20.239 away one token from the bucket and to
02:11:22.559 test it out we can now go back to our
02:11:24.760 HTTP client and try to spam a lot of
02:11:27.960 requests so I'll just keep pressing
02:11:31.480 send there we go transaction is in
02:11:34.239 progress and at one point we reached 429
02:11:38.199 too many requests rate limit exceeded
02:11:41.679 which is exactly what we wanted now if
02:11:44.040 you try making another you'll be able to
02:11:45.960 do it because of the token bucket
02:11:47.599 algorithm which is slowly filling it up
02:11:50.040 but if you once again start spamming you
02:11:52.520 will once again automatically be blocked
02:11:56.000 and check this out within arcet
02:11:58.239 dashboard you can see all of the
02:11:59.840 requests that are being made you can
02:12:02.040 explore more details about the ones that
02:12:04.040 pass through see the complete headers
02:12:06.480 the path the home as well as the IP
02:12:08.639 address that Tred to make them as well
02:12:10.880 as whether it was allowed or blocked in
02:12:13.599 this one it says it's okay but if you
02:12:16.079 head over into one that was rate
02:12:18.360 limited you can see that it was denied
02:12:21.840 for the reason because of rate limit and
02:12:24.440 it will be reset very quickly perfect
02:12:27.599 arcjet also allows you to further
02:12:29.360 configure it so you have even more
02:12:31.480 options of protecting yourself and if
02:12:33.760 you head over into analytics you'll be
02:12:35.960 able to see exactly what is happening on
02:12:37.880 your website are people spamming it or
02:12:40.360 are they using it politely so with that
02:12:42.440 in mind now you know how to secure your
02:12:44.760 apis but keep in mind that arcjet also
02:12:47.520 works with web applications so you can
02:12:49.719 very easily protect your web
02:12:51.480 applications too great now that we know
02:12:54.480 that we're predicted let's focus on our
02:12:56.880 application main functionality and that
02:12:59.679 is creating and tracking the
02:13:03.480 subscriptions let's start with the most
02:13:06.079 important part of our API creating
02:13:08.920 subscriptions and tracking them and
02:13:10.880 cancelling them we'll do that by
02:13:13.119 creating a new file in the controllers
02:13:15.440 folder which I'll call
02:13:18.320 subscription. controller
02:13:21.920 .js within here we can create a new
02:13:24.880 function export con create subscription
02:13:28.639 which will get access to a request a
02:13:30.880 response and next and we'll open up a
02:13:33.719 try and catch Block in the catch we'll
02:13:36.840 get the error and we will simply pass it
02:13:39.280 over to the to the next middleware and
02:13:42.360 in the tri block we can create a new
02:13:44.840 subscription by making it equal to a
02:13:47.520 wait subscription with a capital S
02:13:50.679 because this is referring to a
02:13:51.960 subscription model do create and then we
02:13:54.920 can pass in an object off the
02:13:56.840 subscription details we want to create
02:13:58.840 where we will spread the entire request.
02:14:02.159 body meaning everything that the user
02:14:04.040 passes into this
02:14:05.679 call as well as user is set to rec. user
02:14:11.320 doore ID because we have to know which
02:14:14.320 user is trying to create this
02:14:17.000 subscription and this recre user is not
02:14:20.440 a part of the body because it's coming
02:14:22.440 from the O middleware that we put before
02:14:24.880 creating any subscription to do that we
02:14:27.199 have to go over to subscription routes
02:14:29.920 and where we have create subscription we
02:14:32.440 have to call the authorized function
02:14:34.559 right here one step before it this will
02:14:36.800 populate the request that user with the
02:14:39.040 user information that's currently logged
02:14:40.639 in and if they're not logged in they
02:14:42.800 won't be able to create a subscription
02:14:44.880 this is a very simple thing to do but
02:14:47.199 not everybody does it you should always
02:14:49.480 validate your request with the necessary
02:14:51.679 authorization procedure before creating
02:14:54.320 any kind of document in your application
02:14:56.599 and I've explained all of that in detail
02:14:59.119 in my ultimate NEX CHS course where we
02:15:01.719 write type safe and secure API endpoints
02:15:05.159 you can see just how many validations we
02:15:06.800 have and each lesson has its own GitHub
02:15:09.199 commit so you can track the code so
02:15:11.119 after watching this course if you want
02:15:12.719 to go from being a backend developer
02:15:14.559 into being full stack nextjs is your
02:15:17.239 best bet with that in mind once we
02:15:19.360 create the subscription if the user is
02:15:21.360 authorized let's just return a rest.
02:15:24.119 status of 2011 which means created and
02:15:27.920 we can also pass in an object where
02:15:30.840 success property will be set to true as
02:15:34.040 well as data will be set to be the
02:15:36.239 subscription that was just created now
02:15:38.440 we can get back to the subscription
02:15:40.159 routes and instead of simply saying
02:15:43.079 title create subscription after calling
02:15:45.960 authorized here we can call create
02:15:49.239 subscription coming from controllers
02:15:51.880 subscription.
02:15:53.440 controller.js so let's test it out I'll
02:15:56.000 go to my HTTP
02:15:58.079 client and I'll head over to API V1 not
02:16:02.440 users but subscriptions once again make
02:16:05.360 sure that your authorization header is
02:16:07.520 right here but it is possible that it
02:16:09.840 will be expired if sometime has passed
02:16:12.119 so if that is the case you'll have to
02:16:13.440 log in once again and then add it here
02:16:15.639 just to simulate the fact that you're
02:16:17.119 logged in after that we can change this
02:16:19.360 to a post request and we have to fill in
02:16:21.920 the post body you have to fill it in
02:16:23.960 with all the necessary information such
02:16:26.440 as the name of the subscription like
02:16:28.280 Netflix premium the price $15.99 with a
02:16:31.920 currency of USD frequency of monthly
02:16:35.160 category of entertainment I believe we
02:16:37.318 used lowercase characters and for the
02:16:39.638 start date you can put any date in the
02:16:41.478 past feel free to copy what I have right
02:16:43.679 here 2024 -
02:16:46.080 02-01 and I'm not sure if you need these
02:16:48.318 additional characters as well below this
02:16:50.398 lesson or maybe in a GitHub read me I
02:16:52.679 might include this entire post body just
02:16:54.760 to make sure that you don't have any
02:16:55.879 issues with the validation while trying
02:16:57.558 to create it it looks like we got
02:16:59.040 connection refused which typically means
02:17:01.240 our server is down and it is because our
02:17:04.359 subscription create has to be awaited
02:17:06.679 and I forgot to provide a sync right
02:17:08.920 here at the top so if we fix it we're
02:17:11.799 back on track our subscription tracker
02:17:13.920 is running on Local Host 5000 and our
02:17:16.599 database is connected as well so let's
02:17:18.840 retry that request transaction in
02:17:20.920 progress and there we go 2011 created
02:17:24.638 success true and we got the data for
02:17:27.160 this newly created subscription
02:17:29.280 beautiful and as before this route is
02:17:32.120 completely authorized so if you copy
02:17:34.679 this off token for a second and remove
02:17:36.718 it and try to create a subscription
02:17:39.359 without the a token you'll get 401
02:17:42.879 unauthorized so let's make sure that we
02:17:44.959 have it here now let's create another
02:17:47.080 controller that will give us all
02:17:48.679 subscriptions created by a user just so
02:17:51.040 we can be sure that we have indeed
02:17:52.519 created a subscription we can do that by
02:17:54.519 saying export const get user
02:17:57.638 subscriptions which will be equal to an
02:18:00.120 asynchronous function where we get the
02:18:02.120 request the response and the next in the
02:18:05.240 tri block we can do something but in the
02:18:07.920 catch block we get the error and we can
02:18:10.599 simply forward it over to our error
02:18:12.879 handling
02:18:14.160 middleware and in the try we can check
02:18:17.160 if rec. user. ID is not equal to the
02:18:22.240 rec. ps. ID what does this mean well
02:18:26.240 this means check if the user is the same
02:18:30.000 as the one in the token so if the
02:18:31.478 currently logged in user is trying to
02:18:33.398 get its own subscriptions if we're
02:18:35.558 trying to get it for somebody else it
02:18:37.478 should not work so we can create a new
02:18:40.558 error by saying new error you are not
02:18:44.879 the owner of this account we can also
02:18:47.879 set the status code of 401 unauthorized
02:18:51.718 and throw the error but if we are the
02:18:54.398 rightful owner then we can get all the
02:18:56.760 subscriptions by saying cons
02:18:58.599 subscriptions is equal to await
02:19:01.558 subscription. find where the user is
02:19:04.558 equal to rec.
02:19:06.760 programs. and finally we can return them
02:19:09.599 by saying res. status of 200 that Json
02:19:14.959 success is true and data is equal to the
02:19:17.799 fetch subscriptions so if we head back
02:19:20.120 over to route where we are trying to get
02:19:22.760 the user subscriptions which is this one
02:19:25.080 right here we can now also run authorize
02:19:27.718 right here and then call the get user
02:19:31.000 subscriptions make sure to import it at
02:19:33.080 the top as well so the only thing we
02:19:34.840 have to do to test it out is get our
02:19:37.398 currently logged in user ID we can get
02:19:39.879 it if we go to API V1 users and this
02:19:44.080 will give us our ID so copy it and then
02:19:46.679 modify the URL to API V1 subscriptions
02:19:51.359 for slash user slash and then pass that
02:19:54.479 ID now make a get
02:19:57.040 request and you'll be able to see
02:19:59.160 success true and data which is consisted
02:20:01.640 of an array of all of the currently
02:20:03.680 active subscriptions there is only one
02:20:06.040 so we can see it and the pretty cool
02:20:07.880 part is that we had the start date but
02:20:09.920 as you can see the renewal date has been
02:20:11.800 automatically calculated for US based on
02:20:14.319 that math function that we added that
02:20:16.560 was executed once this document was
02:20:18.680 created now you could totally go ahead
02:20:20.800 and continue implementing the rest of
02:20:23.000 these controllers you already know the
02:20:24.880 trill you have to create a controller
02:20:27.160 and hook it up to the route you can do
02:20:29.160 it on your own for the get all
02:20:31.200 subscriptions as well as get
02:20:32.800 subscription details try doing your best
02:20:34.960 of implementing it but later on we might
02:20:37.600 Implement some of these together but for
02:20:39.479 now let's move to the most interesting
02:20:41.520 part of this project and that is
02:20:43.560 triggering email reminders to let us
02:20:45.960 know that the subscription renewal date
02:20:47.960 is coming so we can turn off our
02:20:49.920 subscription on time let's do that
02:20:54.560 next in this lesson let's Implement
02:20:58.000 workflows a workflow is basically like a
02:21:01.160 message queuing or task scheduling
02:21:03.479 system where the client or an API
02:21:06.280 request triggers a specific workflow to
02:21:08.800 happen in our case we want to schedule a
02:21:11.040 lot of email reminders before our users
02:21:13.960 hit their subscription deadlines giving
02:21:16.000 them more time to think about whether
02:21:17.720 they want to cancel their subscription
02:21:19.439 or keep it going and for that we'll use
02:21:22.160 up stash before we start implementing it
02:21:24.560 I wanted to quickly go over our workflow
02:21:27.000 algorithm or in other words how will our
02:21:29.760 workflows be triggered and how will they
02:21:31.880 behave Step One is of course to trigger
02:21:34.560 the workflow the workflow begins
02:21:36.680 whenever a user creates or submits a new
02:21:39.319 subscription we're going to pass the
02:21:41.280 created subscription ID to our workflow
02:21:44.160 after that we want to retrieve the
02:21:45.840 subscription details specifically we
02:21:48.000 want to extract the subscription ID and
02:21:50.160 then search for the corresponding
02:21:51.880 subscription in the database finally
02:21:54.080 we'll run some checks to see if a
02:21:56.160 subscription doesn't exist then we have
02:21:58.200 an error and we kill the process but if
02:22:00.680 a subscription does exist we'll check
02:22:02.720 its status if it's inactive then we're
02:22:05.520 going to kill the process but if it's
02:22:07.840 active then we want to check out the
02:22:09.880 renewal date if the renewal date has
02:22:11.840 passed then we're going to log this
02:22:13.640 information and exit but if the renewal
02:22:16.520 date is in the future the reminder Loop
02:22:18.920 begins and then we can schedule
02:22:20.640 predefined reminders for example 3 7 or
02:22:24.040 14 days before subscription deadline and
02:22:26.399 send those emails and this process will
02:22:28.640 repeat for all the reminders in the list
02:22:30.720 and after it's done the workflow has
02:22:32.560 done its job let me show you just how
02:22:34.720 simple it is to implement it we'll use
02:22:36.680 up stash so if you haven't already
02:22:38.640 created an account you'll have to create
02:22:40.479 one now click the link in the
02:22:41.760 description to be able to follow along
02:22:43.720 and see exactly what I'm seeing head
02:22:45.920 over to login or create a new account
02:22:48.200 and choose one of the options head over
02:22:49.960 to work flow and copy those environment
02:22:52.399 variables I'll copy the qash URL and
02:22:55.399 head to my env. development. loal where
02:22:58.359 I'll say up stash and I will render an
02:23:01.240 Upstore URL and make it equal to the
02:23:03.800 string that I just copied we also want
02:23:05.640 to get the Q stash token oh that's my
02:23:08.080 bad this was supposed to say Q stash not
02:23:10.120 up stash this will be Q stash token and
02:23:14.200 finally we have the signin keys so let's
02:23:16.840 copy both of these I'll copy first the
02:23:18.920 name paste it here and I'll copy the
02:23:21.319 second name and now we can add those two
02:23:23.800 keys there we go it should look
02:23:25.880 something like this and now that we have
02:23:28.120 our envs we can install appstash client
02:23:31.279 I'm going to do it by following the
02:23:32.880 quick start for Express and the first
02:23:35.359 step is to install appstash workflow so
02:23:37.720 I'll copy this command without the bash
02:23:39.520 at the start just mpm install at upwork
02:23:44.040 flow we have to set up our envs which we
02:23:46.319 have already done and we won't
02:23:47.960 necessarily follow this entire tutorial
02:23:49.960 I mean that will kind of defeat the
02:23:51.359 purpose of of you watching this video so
02:23:54.359 let me teach you exactly what we have to
02:23:56.279 do next we'll keep our code super clean
02:23:59.279 by creating an additional configuration
02:24:01.399 file you can see how much sense it makes
02:24:03.279 to separate all the configs into their
02:24:05.240 own files I'll call it
02:24:08.040 up. JS here I will import
02:24:13.160 client as workflow client coming from
02:24:18.600 /up stash slw workflow and I'll also
02:24:22.160 import our envs oh I think I forgot to
02:24:25.000 add them in ourv config so right here
02:24:28.120 I'll get the
02:24:29.359 qore token as well as the qore URL we'll
02:24:34.080 only need those two for now so here we
02:24:36.439 can import them by importing
02:24:39.479 qore token as well as qore URL from env.
02:24:45.880 JS and finally let's simply export con
02:24:49.520 workflow
02:24:50.960 client is equal to new workflow client
02:24:54.880 and to it we have to pass an object
02:24:57.439 within which we can specify a base URL
02:25:00.080 of Q stash URL as well as the token
02:25:03.279 equal to Q stash token that's it that's
02:25:05.880 the config and now we can create a new
02:25:08.560 file for running all kinds of different
02:25:10.840 workflows let's do it under routes and
02:25:14.359 create a new route called workflow.
02:25:17.680 routes.js within here we can can import
02:25:21.680 router coming from Express we can
02:25:25.680 initialize a new workflow router equal
02:25:29.399 to router which we call like this and we
02:25:32.680 can define a route for example a basic
02:25:35.720 get route for now and finally don't
02:25:38.520 forget to run export default workflow
02:25:42.720 router that way we can use it within our
02:25:45.640 app of course we have to replace this
02:25:47.840 with real workflow logic so let's let
02:25:50.399 head over into the appjs and right below
02:25:53.439 the subscriptions let's duplicate it and
02:25:55.880 call it
02:25:57.600 workflows and just call the workflow
02:26:00.240 router and make sure that it's coming
02:26:01.760 from workflow routes JS now as you know
02:26:04.960 every routes file has to have its own
02:26:07.279 controllers file so create a new file
02:26:10.279 called
02:26:11.319 workflow.
02:26:13.920 controller.js within here we can create
02:26:16.319 a function which will be responsible for
02:26:18.479 sending reminders by by saying export
02:26:21.720 con send reminders and this one will be
02:26:25.279 different from a typical wre and res
02:26:27.760 route this one will be wrapped within
02:26:30.800 serve this serve is coming from upst
02:26:34.800 workflow Express so we can say const d
02:26:38.439 structure to serve and say require at up
02:26:43.520 stash slork flow SL Express and when
02:26:48.399 packages are written as ES modules you
02:26:51.359 could automatically use import to import
02:26:53.920 them but because up stash workflow was
02:26:57.120 likely written using commonjs import
02:26:59.640 won't work directly so we need to use
02:27:01.880 require to import it but in our
02:27:04.840 package.json we have switched type to
02:27:07.520 module which means that we only can have
02:27:10.160 Imports so one way to go over that and
02:27:13.160 still allow this single required
02:27:15.000 statement is to say
02:27:17.640 import D structure create require and
02:27:21.760 that's coming from
02:27:23.479 module and then we can say con require
02:27:26.439 is equal to create require and import
02:27:30.240 that meta that URL and this will allow
02:27:32.560 us to nicely import this up stash
02:27:34.640 workflow now we wrapping this function
02:27:37.120 with a serve and the only thing it'll
02:27:39.359 have is an async function that'll give
02:27:42.319 us access to the context of that
02:27:44.399 workflow and we can then open up a new
02:27:47.319 function block that'll look something
02:27:49.560 like this
02:27:51.080 within here we first want to extract the
02:27:54.279 subscription ID from a specific workflow
02:27:58.200 so let's say subscription ID is equal to
02:28:01.920 context. request payload so when we
02:28:05.359 trigger a specific workflow we will pass
02:28:08.200 the ID of the subscription that workflow
02:28:10.880 is for then let's fetch the details
02:28:13.920 about the subscription by saying con
02:28:16.720 subscription is equal to a wait fetch
02:28:21.760 subscription and it we can pass the
02:28:24.439 context as well as the subscription
02:28:28.359 ID and this fetch subscription function
02:28:31.319 is a new function we can create below by
02:28:33.760 saying const fetch
02:28:35.399 subscription is equal to async will
02:28:39.319 accept the context and the subscription
02:28:41.720 ID and we'll return await context. run
02:28:47.120 so here we're starting the context for
02:28:49.840 get subscription and when it happens
02:28:52.960 we'll open up a new function block where
02:28:55.960 we'll simply return
02:28:58.240 subscription. findind by ID and we'll
02:29:01.000 pass over a subscription ID and we will
02:29:03.439 populate it with user information
02:29:07.160 specifically name and email belonging to
02:29:09.560 that user it looks something like this
02:29:12.520 make sure to have these two return
02:29:14.279 keywords at the start of this code block
02:29:16.319 and at the start of this one because
02:29:18.040 otherwise functions return undefined if
02:29:20.479 you don't explicitly return something
02:29:23.120 great so now we're starting the context
02:29:25.520 of getting the subscription and we're
02:29:27.200 returning it right here next we'll check
02:29:29.960 if there is no
02:29:31.600 subscription or if the subscription.
02:29:34.920 status is not equal to active then our
02:29:38.359 job is done here we can kill the
02:29:40.160 workflow so let's simply say return
02:29:43.319 meaning exit out of this function don't
02:29:45.600 send the reminder else we have to figure
02:29:48.720 out when is the renewal date so let's
02:29:51.200 say con
02:29:52.439 renewal date is equal
02:29:55.680 to and now we could use the regular
02:29:58.279 JavaScript date object and then wrap our
02:30:00.439 renewal date with it but we'll have to
02:30:02.600 do a bit more date and time calculations
02:30:05.240 here and for that I prefer to use a very
02:30:07.800 lightweight package called DJs so in my
02:30:11.120 terminal I'll say mpm install DJs and
02:30:15.120 let's import it at the top I'll do it
02:30:17.600 right here by saying import there ajs
02:30:21.120 from
02:30:23.000 DJs oh and don't forget to import the
02:30:25.479 subscription because we're using it
02:30:27.240 right here so that's going to be import
02:30:29.279 subscription coming from Models
02:30:31.840 subscription model JS and we can have it
02:30:34.359 below because it is a local
02:30:36.960 import great so now we can wrap our
02:30:40.479 renewal date with DJs object
02:30:43.439 subscription. renewal date and then we
02:30:45.479 can have another check and see if
02:30:47.880 renewal date is before and then we can
02:30:50.560 just pass DJs and call it if you call it
02:30:52.960 like that it basically Returns the
02:30:54.479 current date and time so we're checking
02:30:56.240 if renewal date is before the current
02:30:58.720 date and time if it is well then we're
02:31:01.000 going to Simply return a conso log
02:31:03.200 saying something like
02:31:05.840 renewal date has passed for subscription
02:31:09.120 with this ID and we can also add
02:31:12.160 stopping workflow at the end nothing to
02:31:16.000 do there and we can just return meaning
02:31:19.040 exit out of this work flow finally now
02:31:21.479 that we have figured a criteria for when
02:31:23.560 we want to exit out of the workflow
02:31:25.680 let's actually figure out what the
02:31:27.319 workflow will do once we're in it we can
02:31:29.880 do that by creating a list of different
02:31:32.120 reminders for days when we want to send
02:31:34.359 them so I'll say const
02:31:37.319 reminders is equal to an array and we
02:31:40.040 can do something like 7 Days Ahead 5
02:31:43.120 days 2 days and maybe one day so we have
02:31:45.880 different
02:31:47.200 reminders after that
02:31:50.279 we can open up a new for Loop and say
02:31:53.399 four const days
02:31:56.880 before of reminders so from each
02:32:00.439 reminder we'll get the number of days
02:32:02.359 before when we want to send that
02:32:04.080 reminder and then we'll say con reminder
02:32:06.760 date is equal to Renewal date do
02:32:11.680 subtract and we're going to subtract the
02:32:14.319 number of days
02:32:16.160 before just like this by saying reminder
02:32:19.399 date is renewal date and then subtract
02:32:22.680 days before so let me give you an
02:32:24.600 example of that let's say that the
02:32:26.399 renewal date is maybe
02:32:29.359 22nd of February in that case the
02:32:32.479 reminder date is 15th of Feb which is 7
02:32:35.240 days before but then we also have a
02:32:37.279 second reminder which is 5 days before
02:32:39.680 so that's going to be the 17th then
02:32:42.439 we're going to have a 20th and finally
02:32:44.399 one day before on the 21st so we're
02:32:46.640 going to be in a loop each time for each
02:32:48.840 one of these reminders
02:32:50.880 then we want to figure out if reminder
02:32:53.479 date that is
02:32:55.920 after the current date and time so DJs
02:33:00.120 that means that we want to put it to
02:33:01.399 sleep until it's ready to be fired we
02:33:03.760 can do it by creating a new sleep
02:33:06.279 function I'll create it right below and
02:33:08.560 I'll call it const sleep until reminder
02:33:13.120 and it'll be equal to an asynchronous
02:33:15.000 function that accepts the context the
02:33:17.680 label it wants to fire as as well as the
02:33:21.040 date and here we can simply console.log
02:33:24.880 and say something like sleeping until
02:33:27.760 label reminder at specific date and more
02:33:31.319 importantly we can await context. sleep
02:33:35.960 until this specific label and this
02:33:39.680 specific date so date do to date
02:33:43.960 hopefully that makes sense we're putting
02:33:45.359 that reminder to sleep until it's time
02:33:48.000 to trigger it for which we have another
02:33:50.359 function const trigger reminder we'll
02:33:53.240 make it equal to a function that accepts
02:33:55.960 the context as well as the label and
02:33:58.920 then we're going to return await
02:34:01.399 context. run for this specific label and
02:34:05.319 it'll run the following code for now
02:34:07.960 it'll simply say console.log triggering
02:34:11.040 label reminder and then later on we can
02:34:15.120 send an email here or it doesn't even
02:34:17.680 have to be an email it can be an SMS
02:34:20.359 it can be a push notification it can
02:34:23.120 really be anything you want to do you
02:34:24.880 can run any kind of custom logic
02:34:27.240 whenever this reminder is triggered but
02:34:30.120 keep in mind this don't have to be just
02:34:32.200 reminders this could be anything you
02:34:34.160 want to run periodically or you want to
02:34:36.240 run based on some kind of algorithm or
02:34:38.439 logic you are in control we'll figure
02:34:42.000 out how to send this email very soon but
02:34:44.240 for now let's put this reminder to sleep
02:34:46.479 when it needs to sleep and let's trigger
02:34:48.399 it when it needs to be triggered
02:34:50.800 in this if statement I'll say await
02:34:53.560 sleep until
02:34:55.439 reminder and I'll pass a context to it
02:34:58.800 and I'll pass the label the label will
02:35:01.319 look something like this
02:35:03.880 reminder days
02:35:06.399 before days before this is going to be
02:35:09.040 the actual number like five days before
02:35:11.960 and then finally I'll pass the reminder
02:35:14.479 date outside of this if statement we're
02:35:17.160 actually ready to trigger the reminder
02:35:19.000 so say a wait trigger reminder we're
02:35:21.359 going to pass into context and we'll say
02:35:23.840 reminder for 5 days before for example
02:35:26.720 so let's figure out these functions
02:35:28.640 first we're fetching the subscriptions
02:35:30.439 we're checking if that renewal date is
02:35:32.399 maybe in the past or if the subscription
02:35:34.359 doesn't exist or if the status is not
02:35:36.319 active in all of these cases we just
02:35:39.040 stop the reminders from going but once
02:35:41.439 we figure out that it is an active
02:35:42.880 subscription and it has a renewal date
02:35:44.800 that is in the future we map over all of
02:35:47.359 the reminders that we specified like
02:35:49.359 five 5 days before 7 Days 2 Days 1 day
02:35:52.760 and then we figure out when to put it to
02:35:54.640 sleep and when to actually trigger it
02:35:57.279 and we use these helper functions such
02:35:59.120 as sleep until or trigger to make it do
02:36:01.760 its job and let's trigger the workflow
02:36:04.560 we'll do it right after the subscription
02:36:06.560 gets created the only thing we have to
02:36:08.479 do is say await
02:36:12.359 workflow client this is coming from up
02:36:15.240 stash so import it at the top dot
02:36:18.279 trigger and we're going to pass in an
02:36:20.720 object of additional info for this
02:36:23.720 workflow we want to trigger first it
02:36:26.000 needs a URL so which API endpoint do we
02:36:29.080 have to call to be able to run this
02:36:31.359 workflow it'll be starting with
02:36:34.560 server _ URL and you'll have to add it
02:36:38.040 over in your env. development. looc so
02:36:42.000 scroll to the top and if you haven't
02:36:44.080 already and I don't believe you have you
02:36:46.399 can add this server URL is equal to and
02:36:50.720 put your current local host address HTTP
02:36:55.359 Colin localhost
02:36:57.760 5500 usually you would have to deploy
02:37:00.479 the entire app and use a production URL
02:37:03.000 to test any kind of scheduling type of
02:37:04.880 workflow or use something called enrock
02:37:07.600 to do it it has a super complex setup
02:37:10.560 but luckily for us upstage provides an
02:37:12.920 easy local development server that won't
02:37:15.760 just save you time and a lot of headache
02:37:17.600 from going through complex setups but
02:37:19.720 also save you money from running all of
02:37:21.640 those test workflows you have unlimited
02:37:24.560 tests here so let me show you how to do
02:37:26.479 it I'll open up a third terminal which
02:37:29.120 will run our local development server
02:37:31.479 and for now I'll run MPX
02:37:34.720 upq stash - CLI Dev It'll ask us whether
02:37:39.520 we want to install that package I'll say
02:37:41.760 why go ahead as soon as you do that in
02:37:43.800 the terminal you'll get a URL and a
02:37:46.319 dummy token copy those and add them over
02:37:49.200 to env. development. local let's add
02:37:52.960 them below current up stash envs and
02:37:55.439 then move the original ones over to our
02:37:58.399 second EnV file env. production. loal so
02:38:03.680 this is going to be up stash and it'll
02:38:05.560 paste them right here oh and this is
02:38:07.399 important check out this sample curl
02:38:09.760 request that up stash has given us to
02:38:11.920 test this out hidden within it there's a
02:38:14.160 q stash URL so copy this starting part
02:38:17.040 of this up to the 8080 part
02:38:20.000 and then head back to the development
02:38:21.760 part and say Q store URL and make it
02:38:25.920 equal to this HTTP col SL1
02:38:31.240 1271 880 so now we have two different
02:38:34.520 instances of up stash one for testing in
02:38:37.640 development and one for production also
02:38:40.439 in production we need these Q stash
02:38:43.200 current and next signing keys but in
02:38:45.680 development we don't actually need them
02:38:48.240 so I will completely remove them from
02:38:50.359 development you need to remove them in
02:38:52.200 order for everything to work let's
02:38:54.120 actually copy this entire curl request
02:38:56.399 and let's leave this third terminal to
02:38:57.960 be running I'll rename it as up stash
02:39:01.359 the first one will be our own server so
02:39:03.359 I will rename it to server and within
02:39:06.160 this terminal which I'll simply call
02:39:08.200 terminal we can run some additional
02:39:10.399 commands such as running this curl
02:39:13.080 command that was given to us by up stash
02:39:16.399 I'll press enter and you can see that we
02:39:18.800 get back a message ID of message 2K XD
02:39:23.040 this is a random workflow ID generated
02:39:25.920 for us in the terminal which means that
02:39:28.000 our workflows are indeed generating
02:39:29.880 locally but let's not forget the
02:39:32.120 workflow routes if you think about it we
02:39:35.200 never actually got the opportunity to
02:39:37.000 use the send reminders workflow that we
02:39:39.240 created not that long ago of course this
02:39:41.399 one right here is the one I'm referring
02:39:43.040 to send reminders so we'll call it once
02:39:46.880 we hit this endpoint which is supposed
02:39:49.000 to trigger the workflow I simply have to
02:39:51.240 say send reminders and import it from
02:39:54.000 controllers workflow controller.js but
02:39:56.319 then when are we actually going to fire
02:39:58.040 it well the answer lies in the
02:40:00.960 subscription controller because here we
02:40:03.160 have defined the URL so it's going to be
02:40:05.600 API V1 workflows and then SLS
02:40:09.200 subscription SL reminder and it is a
02:40:12.080 post request so let's say workflow
02:40:14.439 router. poost SLS subscription SL
02:40:18.439 reminder and and then we call the send
02:40:20.240 reminders
02:40:21.200 function now we ready to test it out
02:40:23.920 back in our HTTP client I prepared my
02:40:26.439 route of Local Host 5500 API V1
02:40:30.800 subscriptions I have my bare token right
02:40:33.319 here as well as the body of the new
02:40:35.439 subscription I'm trying to make this is
02:40:37.600 a subscription for JS Mastery pro elite
02:40:40.160 membership we have the price the
02:40:42.080 currency and the category as well as the
02:40:44.920 start date so what do you say that we
02:40:47.279 give it a shot I'll click
02:40:50.160 send and we get a 2011 created that's
02:40:53.960 amazing but hey this worked before this
02:40:56.680 is nothing new so what matters more here
02:40:59.840 is that now alongside the newly created
02:41:02.080 subscription we also get a workflow run
02:41:05.800 ID it ends with OMG okay so let's see if
02:41:10.439 we get anything in the terminal back
02:41:12.200 into the code if you go to the up stash
02:41:15.120 terminal you'll see that we have some
02:41:17.160 kind of a message ID with a workflow run
02:41:19.960 OMG but now if you head into your server
02:41:22.520 terminal it looks like we got a small
02:41:24.760 type error this converting circular
02:41:27.200 structure to Json especially when
02:41:29.080 mentioning a Mongol client object
02:41:31.319 typically refers to forgetting to pass
02:41:33.200 an async or an await before some kind of
02:41:35.720 a mongoose action so if we head over
02:41:38.359 into workflow controller and pay
02:41:40.840 attention to the only Mongoose caller
02:41:43.120 making here subscription. find by ID we
02:41:46.120 actually have to turn this function into
02:41:48.200 an asynchronous function that'll resolve
02:41:50.720 the error also if I scroll a bit above
02:41:54.000 you'll notice that here I said
02:41:55.600 subscription status is not active but
02:41:58.080 this active is actually an undefined
02:42:00.000 variable what I meant to do was say
02:42:02.200 active within string signs because the
02:42:05.399 status is literally a string of active
02:42:07.520 so now that I fixed those let's just
02:42:09.439 render another subscription we get true
02:42:11.880 this time ending with 6kb and if I get
02:42:14.720 back you can see sleeping until reminder
02:42:17.960 5 days before and reminder will happen
02:42:20.600 at and of course this date and time will
02:42:22.680 be different for you so this is great it
02:42:25.279 means our workflows are working but just
02:42:27.840 seeing these workflow IDs and console
02:42:30.080 logs within terminal is not that fun so
02:42:32.800 let's head into the workflow controller
02:42:35.760 and scroll down to the part where we
02:42:37.560 left a comment when we trigger a
02:42:39.279 reminder we want to do something we want
02:42:42.000 to send an email or an SMS or a push
02:42:44.359 notification and that's exactly what
02:42:46.720 we'll do in the next lesson then we'll
02:42:48.680 be able to utilize the full power of the
02:42:50.840 flexibility of these workflows to
02:42:53.080 trigger custom email reminders so let's
02:42:55.800 do that next in this lesson I'll teach
02:42:59.000 you how to use node mailer a free module
02:43:01.680 for noj applications that allows for
02:43:04.040 easy email sending and of course we'll
02:43:06.160 integrate it with our workflows so let's
02:43:08.760 run mpm install node mailer I'll put
02:43:11.399 that straight within our terminal and to
02:43:13.760 make node mailer work we'll use our
02:43:15.760 Gmail account as our email transporter
02:43:18.760 so head over to your Gmail account go to
02:43:21.240 settings in your profile and for this to
02:43:23.560 work if you haven't already you'll have
02:43:25.479 to turn on the twostep verification for
02:43:27.760 your email it's like an extra layer of
02:43:29.680 security it's good to have it anyway but
02:43:31.960 in this case you'll have to have it for
02:43:33.760 node mailer to work so just follow the
02:43:35.640 steps to turn it on but if you're a good
02:43:37.920 developer that cares about security I
02:43:39.800 believe it's already on for you then
02:43:41.920 once you enable it you select your
02:43:43.800 account and click manage your account
02:43:45.960 right here on the homepage search for
02:43:48.120 app
02:43:49.600 passwords and click the first link under
02:43:52.399 security then enter the app name in this
02:43:55.399 case I'll choose subscription tracker
02:43:58.399 and click create and then just copy the
02:44:00.439 password you were given back within your
02:44:02.399 editor head over to env. development.
02:44:06.080 local and at the bottom add a new node
02:44:10.200 mailer comment and here we can say email
02:44:13.600 password is equal to and then you can
02:44:15.840 paste the password that you just got and
02:44:18.120 here you can also export the email
02:44:20.600 password then let's create a new
02:44:22.880 configuration file I think you can see
02:44:25.120 how useful having this structure is and
02:44:27.840 I'll call it node
02:44:30.080 mailer
02:44:31.840 DJs here we can configure a transporter
02:44:35.319 using Gmail as a service by saying const
02:44:39.720 transporter is equal to node
02:44:43.720 mailer do create
02:44:46.880 transport and make sure to import node
02:44:49.680 mailer right at the
02:44:51.960 top from node mailer like this next we
02:44:57.439 can Define Service as Gmail and then o
02:45:01.319 equal to user will be equal to your
02:45:05.000 account email in my case it'll be
02:45:07.560 JavaScript Mastery
02:45:09.840 @gmail.com choose the Gmail account that
02:45:13.720 you enabled your two-step verification
02:45:15.600 on and through which you created your
02:45:17.600 app password
02:45:19.439 it has to be the same one and then right
02:45:22.279 here we can put the pass which will be
02:45:24.880 equal to email password coming from VJs
02:45:30.760 now we can create a common reusable HTML
02:45:33.960 templates for all different kinds of
02:45:35.760 reminders to create it create a new
02:45:38.520 folder called utils like utility
02:45:41.800 functions and within utils create a new
02:45:44.680 file called email- template. Js I've
02:45:49.439 just used VZ to quickly generate a
02:45:51.640 template it's basic HTML and CSS and I
02:45:54.640 told it to include all the important
02:45:56.240 things such as username email
02:45:58.399 subscription date and all that good
02:46:00.080 stuff so I'll leave it either below this
02:46:02.479 lesson or within the assets part of the
02:46:05.200 GitHub readme of this project so just
02:46:08.080 copy from there and then paste it here
02:46:10.800 you'll notice that it is a single
02:46:12.479 function called generate email template
02:46:15.000 which is basically just a div with a lot
02:46:17.000 of CSS Styles but then
02:46:19.560 it mentions the subscription name the
02:46:21.520 plan name the username and all the
02:46:23.640 important stuff that we pass through it
02:46:26.080 we also have different templates like 7
02:46:27.960 days before 5 days before 2 days before
02:46:31.200 and then we call the actual function and
02:46:33.640 generate the subject in the body of that
02:46:35.840 specific email once again nothing
02:46:37.840 special is happening here we're just
02:46:39.600 returning HTML now let's put it to use
02:46:42.640 let's write the actual logic that will
02:46:44.800 send the reminder email we can do it
02:46:46.880 within a new file within the utils
02:46:48.560 folder
02:46:49.439 and let's call it
02:46:51.120 send-email
02:46:52.920 DJs within here we can export const send
02:46:57.680 reminder email which will be equal to an
02:47:01.040 async function it'll look something like
02:47:03.479 this and as the first and only parameter
02:47:06.120 it'll accept an object so we can
02:47:07.920 destructure it and it'll have the two
02:47:10.399 property who we're sending the email to
02:47:13.640 the type
02:47:15.279 property and the subscription
02:47:19.760 so now that we have D structured those
02:47:21.760 we can say if there is no two or if
02:47:25.120 there is no type we can simply throw a
02:47:27.840 new
02:47:28.880 error and say something like missing
02:47:31.960 required
02:47:34.840 parameters if it exists we can create a
02:47:38.040 new template by calling the email
02:47:43.600 templates and calling the find method on
02:47:46.160 it where we're going to look into the
02:47:48.560 type that we have and then based on the
02:47:51.160 t. Lael we'll compare it with the type
02:47:54.200 that we
02:47:55.960 have and that'll be the template we'll
02:47:58.279 use for this specific reminder if it's 5
02:48:01.120 days until we'll find that in the email
02:48:03.600 templates and we'll say five days
02:48:05.160 reminder if it's seven days it'll be
02:48:07.080 seven if it's one it'll be one once we
02:48:10.000 have the template we can check if we
02:48:11.840 have it if we don't we can say invalid
02:48:14.760 email
02:48:15.960 type and finally we can form an object
02:48:19.160 containing the full user info I'll call
02:48:22.439 it mail info
02:48:25.399 username is
02:48:28.000 subscription.
02:48:29.560 user.name
02:48:32.640 next we're going to have a subscription
02:48:35.720 name which will be equal to
02:48:38.319 subscription.
02:48:40.200 name let's spell it
02:48:43.640 properly after that we're going to have
02:48:45.640 the renewal date which will be equal to
02:48:50.000 DJs
02:48:52.279 subscription. renewal
02:48:55.680 date and I'm going to even format it
02:48:59.479 to
02:49:01.120 MMM d y y y y this is just a format
02:49:06.319 where it'll say something like January
02:49:08.080 1st 2030 or something like that we're
02:49:11.200 going to also have a plan name so
02:49:13.920 that'll be the
02:49:15.160 subscription. name we also have the
02:49:17.600 price
02:49:20.160 and it'll be equal to Let's format it
02:49:26.040 subscription do
02:49:28.160 currency after that subscription. price
02:49:32.479 and then finally in parentheses we can
02:49:35.200 render the
02:49:37.680 subscription.
02:49:40.520 frequency so it's going to say something
02:49:42.800 like USD 10
02:49:47.279 monthly and can also render a payment
02:49:50.399 method which will be equal to
02:49:53.520 subscription. payment
02:49:56.319 method
02:49:58.680 perfect finally let's form the actual
02:50:01.439 message by saying const message is equal
02:50:03.960 to template. generate body and we'll
02:50:08.160 generate the mail
02:50:11.120 info and finally there is the subject of
02:50:14.600 that email which will be equal to
02:50:16.439 template. generate subject
02:50:19.920 we'll pass the mail info and finally we
02:50:22.880 can form the final mail options by
02:50:25.359 saying const mail options is equal to
02:50:29.080 from will be equal to the account
02:50:33.319 email to will be equal to two subject
02:50:38.160 will be equal to
02:50:41.880 subject and finally HTML will be equal
02:50:45.080 to the message that is coming from the
02:50:47.239 template oh and and let's make sure that
02:50:49.399 we know where this account email is
02:50:51.520 coming from it has to be the same as the
02:50:53.760 one that we have chosen right here in
02:50:55.439 node mailer config so we could actually
02:50:58.520 separate it from here and Export it by
02:51:01.479 saying export const account email is
02:51:05.359 equal to and now I can copy this string
02:51:09.399 put it
02:51:10.600 here so I can refer to the account
02:51:15.720 email and then we're exporting it
02:51:19.200 and back in the send email we can import
02:51:22.120 this account email coming from config
02:51:25.319 nodemailer DJs finally from the node
02:51:28.600 mailer we'll also import our instance of
02:51:31.359 the transporter with our
02:51:35.880 configuration and now that we have all
02:51:38.080 the information we can say
02:51:40.920 transporter.
02:51:43.880 sendmail with all the mail
02:51:46.399 options and as the second parameter
02:51:48.960 we're going to get access to the error
02:51:50.720 or the information for that email and if
02:51:53.800 there is an error we will simply
02:51:57.000 return a conso
02:52:00.200 log and say error as well as error
02:52:03.600 sending email else we will simply consol
02:52:07.160 log email sent and I'll also add the
02:52:09.920 info response of that
02:52:12.200 email now where are we going to call
02:52:14.720 this send reminder email function
02:52:17.160 from well we're we're going to call it
02:52:19.200 from the workflow controller so head
02:52:21.760 over into the workflow controller and
02:52:24.160 remember this comment we're finally back
02:52:26.880 right here I'll simply say await send
02:52:30.920 reminder email make sure to import it
02:52:34.880 from utils send mail.
02:52:37.399 JS and to it we have to pass a couple of
02:52:40.239 things it'll be an object of the two
02:52:43.920 property and we want to send it to
02:52:46.640 subscription. user. email so whoever
02:52:49.760 created that subscription and we have to
02:52:52.040 pass the type of the subscription which
02:52:54.359 will be equal to reminder. label.
02:52:57.680 subscription so either 5 days until 7
02:53:00.319 days until 3 days until and so on let's
02:53:03.439 open up our terminal to see if we have
02:53:05.239 any errors because we have modified a
02:53:07.239 lot of code looks like we have one error
02:53:09.800 in workflow controller line
02:53:13.239 49 and that is right here where I added
02:53:15.960 a weight to be able to add a weight
02:53:18.279 right here I have to make the function
02:53:20.279 I'm calling the a weight within
02:53:22.920 async so let me add it
02:53:27.080 there and that fixed the error now we
02:53:29.880 have another error in send email. JS so
02:53:33.720 if I head over
02:53:34.960 here we're importing the
02:53:37.720 transporter but are we actually
02:53:39.680 exporting it oh looks like we're not so
02:53:42.880 let's run export default
02:53:45.359 transporter and with that that second
02:53:47.600 error is now gone gone subscription
02:53:49.720 tracker API is running and we're
02:53:52.239 connected to the database so back in our
02:53:54.880 HTTP client let's try to create a new
02:53:57.920 subscription this time I'll do it for
02:54:00.279 Amazon Prime in a currency of USD
02:54:03.479 category
02:54:04.439 entertainment and feel free to test it
02:54:06.960 with different days right here I'll
02:54:09.840 choose a date that is 7 Days from my
02:54:12.600 current date you can of course choose a
02:54:15.200 date that is 7 Days from your date and
02:54:18.040 if I now click Send of course we get a
02:54:20.399 2011 we've gotten good at getting those
02:54:22.600 and not errors we get back the
02:54:24.720 subscription that we
02:54:26.000 created with automatically calculated
02:54:28.640 renewal date and we got a new workflow
02:54:31.800 that we ran oh it looks like I have
02:54:34.120 another reference error it is happening
02:54:36.640 within the workflow controller I haven't
02:54:39.080 defined the subscription so let me
02:54:41.640 quickly head over into the workflow
02:54:43.720 controller and here it looks like I'm
02:54:46.200 referring to a subscription but I don't
02:54:48.920 really have access to it within this
02:54:50.920 trigger reminder function so when we're
02:54:53.439 calling this trigger reminder and we're
02:54:55.560 calling it right here maybe as the third
02:54:58.520 parameter I need to pass the actual
02:55:01.840 subscription here we do have it as you
02:55:04.359 can
02:55:06.399 see then I can accept it as the third
02:55:10.040 parameter subscription and now we should
02:55:12.680 have access to it what about the
02:55:14.399 reminder I don't think we have that
02:55:16.520 either and it's not like we can can very
02:55:18.640 easily pass it but this reminder label
02:55:22.080 is basically just this label which we're
02:55:24.520 already passing through and this label
02:55:27.160 has to exactly match the one within
02:55:29.800 email templates where it says 7 days
02:55:32.880 before reminder five days before
02:55:35.120 reminder two days before reminder and
02:55:37.239 one day before reminder so that's
02:55:40.000 7521 and then we have the final I think
02:55:42.560 I can even get rid of this final we can
02:55:44.439 just keep it
02:55:46.680 7521 and it has to match exactly so
02:55:49.600 let's copy it and let's compare it here
02:55:52.880 I have reminder days before days before
02:55:56.000 but actually we have to start with the
02:55:58.880 number then days before and then finally
02:56:02.640 reminder like this so that's going to
02:56:05.239 then look something like this two days
02:56:08.239 before reminder perfect so now we're
02:56:11.520 passing that as a label so the type can
02:56:14.279 be just label and then we can pass the
02:56:16.680 entire subscription equal equal to
02:56:19.120 subscription we need it to send that
02:56:21.120 email reminder so let's test it once
02:56:23.840 again by creating another subscription
02:56:26.720 and take a look at this sleeping until
02:56:29.359 reminder 5 days
02:56:31.640 before email
02:56:33.920 sent okay and we get the ID of the email
02:56:38.319 beautiful now of course this email will
02:56:41.439 get to the email of the user that
02:56:43.479 created the subscription so if you want
02:56:45.520 to know which one is that you can copy
02:56:47.840 the ID of the user that created the
02:56:50.040 subscription and then go to get
02:56:52.680 localhost API V1
02:56:55.800 users and then paste over that user ID
02:56:59.160 and you'll get your email right here and
02:57:01.479 check this out what a nice caption right
02:57:03.760 here reminder your Amazon Prime
02:57:06.200 subscription renews in 7 Days hello
02:57:08.920 Adrien your Amazon Prime subscription is
02:57:11.120 set to renew plan price payment method
02:57:15.000 if you'd like to make changes or cancel
02:57:16.640 the subscription visit your account
02:57:18.960 settings before the renewal date or
02:57:21.359 contact our team of course none of these
02:57:24.200 links are real but you get the idea of
02:57:27.160 what is possible by creating your own
02:57:29.600 API now with workflows allowing you to
02:57:32.680 trigger and send emails to people that
02:57:35.359 want to get reminded now let's try to
02:57:37.880 make another subscription but this one
02:57:40.319 will have a closer renewal date so we're
02:57:43.200 not looking to trigger the 7day reminder
02:57:45.640 but maybe the 2-day or one day reminder
02:57:48.479 right now it's February 7th for me so
02:57:50.920 I'm going to make it seem like I
02:57:52.960 subscribed on the 9th of January which
02:57:55.960 means that there should only be 2 days
02:57:58.359 left until the renewal on February 9th
02:58:01.319 you can change it depending on your
02:58:03.120 current date and time but before we
02:58:05.239 trigger it there's just one fix that we
02:58:07.239 have to add in our workflow controller
02:58:09.680 and that is right here where we're
02:58:11.760 triggering the reminder currently if
02:58:15.120 we're only two days away what would
02:58:17.319 happen is we're going to go into this
02:58:19.080 for Loop and we're going to trigger all
02:58:21.200 of the reminders in the row 7 5 3 2 1
02:58:25.800 but instead if we're already so close
02:58:28.359 the renewal date we have to have an if
02:58:30.439 statement right here and check if now is
02:58:35.080 same reminder date day only if that is
02:58:38.960 the case then trigger this reminder oh
02:58:42.319 and if I'm not mistaken instead of using
02:58:44.160 the word now we can just call the
02:58:46.800 DJs as a function because that will
02:58:49.680 render the current date in time and then
02:58:51.840 we're checking whether currently is the
02:58:53.960 same as the reminder date only then send
02:58:56.720 it now let's trigger that new
02:58:59.239 subscription that has a renewal date
02:59:01.239 that is only 2 days away there we go we
02:59:04.080 get a 2011 created with new subscription
02:59:07.279 data and a new workflow run ID back in
02:59:10.479 the terminal we now only see one email
02:59:13.200 sent instead of like seven and most
02:59:16.399 importantly take a look at this
02:59:18.760 email caption changed to a bolt saying
02:59:21.880 final reminder Amazon Prime renews
02:59:25.000 tomorrow hey Adrian your subscription is
02:59:27.720 set to renew on February 8th one days
02:59:30.479 from today
02:59:33.080 beautiful so now that we know that our
02:59:35.160 workflows are flowing emails are sending
02:59:39.239 and subscriptions are getting created
02:59:41.120 and tracked ready for us to cancel them
02:59:43.840 if we don't want to keep paying which
02:59:45.840 means that our app has done its job in
02:59:49.120 the next lesson let's deploy and host it
02:59:52.520 to your own virtual private server so
02:59:55.479 you have complete flexibility over how
02:59:57.520 you want to host it and how you want to
02:59:59.479 let other people access it who knows
03:00:02.399 maybe you even put it behind the pay
03:00:03.760 wall and start making some money from it
03:00:06.520 the possibilities are endless but enough
03:00:09.680 talking let's deploy it on a VPS and
03:00:13.359 finally we are ready to host our API on
03:00:16.040 our VPS if you followed the line long at
03:00:18.439 the start when I was just starting to
03:00:20.279 create the API I led you through the
03:00:22.640 process of getting your own virtual
03:00:24.800 private server the cheapest plan will be
03:00:26.640 more than enough so you can choose it
03:00:28.800 and enter your JavaScript Mastery coupon
03:00:30.920 code as this will give you an additional
03:00:32.840 discount so if you haven't yet gotten it
03:00:35.000 you can get it now or if you already got
03:00:37.080 it we can continue from the dashboard
03:00:39.160 once you're in you should be able to
03:00:40.640 find an on boarding for your VPS if you
03:00:43.160 can't see it don't worry you'll still be
03:00:45.040 able to set up everything from your
03:00:46.600 dashboard choose the location that is
03:00:48.640 closest to you no need to get this
03:00:50.520 additional malware scanner here you'll
03:00:52.680 have to create your secure root password
03:00:55.960 you can click here to autogenerate but
03:00:58.080 then make sure to copy it and save it
03:01:00.359 somewhere safe such as in our env.
03:01:03.600 development where we can say VPS and
03:01:07.239 here I can enter my password as well as
03:01:10.880 the name which is root and then click
03:01:13.800 continue and since we have chosen the
03:01:15.880 no. JS VPS it comes with a latest
03:01:18.160 version of auntu as well as no. JS
03:01:20.399 pre-installed so let's finish the setup
03:01:23.040 this will take a couple of minutes so
03:01:24.800 feel free to pause this video and I'll
03:01:27.160 be right back there we go this was
03:01:29.439 quicker than I anticipated let's also
03:01:31.560 somewhere securely store this SSH access
03:01:34.399 by copying it and then heading over into
03:01:37.000 ourv and just pasting it right here as a
03:01:39.680 comment and then head over to manage VPS
03:01:42.600 now in case you somehow missed the
03:01:44.239 onboarding that's totally okay because
03:01:46.680 you can change your password right here
03:01:48.840 and you have your SSH terminal here and
03:01:51.319 then if you want to change your
03:01:52.359 operating system or settings it is all
03:01:55.239 here on the left now what you could do
03:01:58.040 is use a regular terminal like iterm
03:02:01.000 bash or Powershell but hostinger also
03:02:03.560 prepared this very nice browser terminal
03:02:05.920 so you can just click here and you're in
03:02:08.160 there once the terminal opens you'll be
03:02:10.680 able to see some information about your
03:02:12.399 system and it's going to ask you about
03:02:14.520 your domain for the time being just
03:02:16.840 simply press control see and that'll
03:02:18.880 exit out of the setup and then clear it
03:02:21.840 and then I'll Zoom it in so we can see
03:02:23.520 it a bit better it looks like we're
03:02:25.040 already within our system how do I know
03:02:27.359 that well that's because if I type
03:02:29.279 something like MK deer and then the name
03:02:32.479 something like folder and then press LS
03:02:35.640 you'll see that a new folder was created
03:02:37.960 and now I can delete it using
03:02:40.160 rm-rf
03:02:42.319 folder and now LS nothing is there so
03:02:45.520 you have a complete access to another PC
03:02:47.880 see right within your terminal in case
03:02:50.479 you don't want to use hostinger built-in
03:02:52.120 terminal you can open up any kind of
03:02:54.239 terminal on your device but how do you
03:02:56.439 get from this terminal into that device
03:02:58.760 well you can copy this SSH root paste it
03:03:02.279 in you can say yes I want to connect to
03:03:04.640 it and then you'll have to enter the
03:03:07.000 password thankfully we have it here so
03:03:09.520 just copy it paste
03:03:12.800 it and press enter and you're in now you
03:03:17.160 can once again press contrl C and you're
03:03:19.680 within the system either way is fine but
03:03:22.640 I'll be using the terminal built into
03:03:24.239 the browser now first things first as a
03:03:26.720 recommended practice we want to update
03:03:28.920 all of our packages installed on our VPS
03:03:31.279 computer and you can do that by running
03:03:33.800 apt update and apt upgrade
03:03:37.920 y this command will update all the
03:03:40.760 packages and it'll also upgrade all the
03:03:43.760 packages on a Debian BAS system and the
03:03:47.080 Y flag automatically confirms the
03:03:49.399 upgrade this could take about a minute
03:03:52.239 but it's good to know that all of our
03:03:53.760 packages will be updated and upgraded so
03:03:57.160 let's wait until it finishes and I'll be
03:03:59.399 right back there we go that seems to
03:04:01.920 have been successful so let's clear it
03:04:04.960 and now since we'll be developing a
03:04:06.960 node.js application let's install it by
03:04:09.760 running apt install nodejs if we're
03:04:13.319 using bun or Deno you would install it
03:04:15.760 here but thankfully in our case this VPS
03:04:19.239 already came in with the latest version
03:04:21.120 of node.js installed so we're good and
03:04:24.040 we can verify it by running node DV if
03:04:27.720 you get any kind of number here you're
03:04:29.680 good and for some reason this nodejs
03:04:32.439 installation does not come with the
03:04:34.040 respective mpm package manager so let's
03:04:36.960 install it separately by running apt
03:04:39.880 install mpm now it looks like there are
03:04:43.279 some problems but let's just check
03:04:45.520 whether we have a version of mpm install
03:04:47.399 by running mpm DV and we do get it that
03:04:51.680 means we're good but in addition to the
03:04:53.720 node manager we also need a systemwide
03:04:57.000 process manager that will ensure that
03:04:58.920 our tasks continue running even after
03:05:01.560 crashes or reboots and automatically
03:05:04.200 restart them in the background on our
03:05:06.080 VPS server in case of failure there's an
03:05:08.880 mpm package that we can install for that
03:05:11.000 called pm2 so just run mpm install -
03:05:15.439 gpm2
03:05:17.760 there we go and on top of that we'll
03:05:20.479 also need a git system installed so we
03:05:22.880 can easily transfer our codebase from
03:05:25.080 our local device to GitHub and then to
03:05:27.840 the VPS while there are other methods I
03:05:30.520 found git to be the simplest especially
03:05:32.560 for updating the API even after making
03:05:35.040 changes to install it simply run apt
03:05:38.560 install
03:05:40.239 g-y super simple now head over to GitHub
03:05:44.479 and create a new repo you can call it
03:05:47.279 however your API is called in this case
03:05:50.000 I'll say something like subscription
03:05:52.600 tracker and I'll click create repo then
03:05:55.880 open up your terminal and run get init
03:05:59.760 get add dot git commit DM initial
03:06:08.160 commit git Branch M
03:06:12.880 Main and then copy this git remote ad
03:06:16.080 origin
03:06:18.960 as well as get push U origin Main in a
03:06:22.279 matter of a second the entire codebase
03:06:24.720 will be pushed to Main and then you'll
03:06:26.560 have to grab this link so we can clone
03:06:28.760 it over to our VPS machine so back in
03:06:31.840 our VPS terminal you can now say get
03:06:34.160 clone and you can paste the URL you just
03:06:36.439 copied it'll clone it and then you can
03:06:39.239 press LS LS stands for list and it's a
03:06:43.760 command that simply lists files and
03:06:45.600 directories in the current directory in
03:06:47.600 your Operating System since we don't
03:06:49.560 have a visual graphical user interface
03:06:52.040 we use it to see available files and
03:06:55.359 folders here you can see the folder we
03:06:59.640 created now we have to set up a couple
03:07:02.000 of things inside of it so to navigate
03:07:04.640 inside of that folder in a Unix based
03:07:07.080 system we can use the CD command CD
03:07:10.520 stands for change directory and it's
03:07:13.080 used to navigate between different
03:07:14.680 directories you can just start typing
03:07:17.239 and then then press enter and it'll
03:07:19.160 actually autofill the entire name and
03:07:21.880 press enter and now we can see the path
03:07:24.160 has changed and we're officially within
03:07:26.560 the subscription
03:07:27.720 tracker so now if you press LS you can
03:07:31.239 see all the files and folders we worked
03:07:33.479 so hard to create once you verify that
03:07:35.840 you're in you'll have to run mpm install
03:07:39.160 to install all of the dependencies this
03:07:41.760 time within our VPS and the next couple
03:07:44.760 of steps are tough and they're going to
03:07:46.680 depend on the oper in system you chose
03:07:48.840 and there's a lot of things that can
03:07:50.640 break so I don't want to just record it
03:07:53.319 and make it work for me but then it's
03:07:55.000 possible that it won't work for you that
03:07:57.120 wouldn't be a good video so for that
03:07:59.000 reason I decided to create a completely
03:08:01.359 free VPS hosting and debugging guide
03:08:04.720 where I'll list all the steps one by one
03:08:07.279 with debugging instructions so if
03:08:09.279 something goes wrong you can easily fix
03:08:11.120 it I'll link it somewhere below this
03:08:12.920 lesson or in the GitHub read me of this
03:08:14.760 repo you'll be able to follow along and
03:08:16.840 finish it there but with that in mind
03:08:18.840 this was a huge course so patch yourself
03:08:21.399 on the back because you built your own
03:08:23.520 API but as I said we're not finishing
03:08:26.080 here in that free guide that will always
03:08:28.279 be up to date you can finish this course
03:08:30.560 and deploy this API to a VPS so it
03:08:33.279 becomes publicly and globally accessible
03:08:35.880 thank you so much for watching and I'll
03:08:37.880 see you in the next one until then have
03:08:40.439 a wonderful day
